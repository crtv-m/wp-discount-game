<?php 
/**
* Plugin Name: Discount Game
* Plugin URI: 
* Description: 
* Version: 0.13
* Requires at least: 5.6
* Requires PHP: 8.1.29
* Author: krtv-m
* Text Domain: DG
* Domain Path: /languages
* Copyright 2024 - discount game
*/
?>

<html>
  <body id="t" i18n-values=".style.fontFamily:fontfamily;.style.fontSize:fontsize" jstcache="0" class="offline" style="font-family: &quot;Segoe UI&quot;, Tahoma, sans-serif; font-size: 75%;">
    <style>
      /* Day & Night */
      html {
        overflow: hidden;
      }

      .offline .interstitial-wrapper {
        display: flex;
        justify-content: center;
      }
      
      .offline .runner-container {
        direction: ltr;
        height: 250px;
        overflow: hidden;
        position: absolute;
        top: 100px;/* Top */
        width: 44px;
      }
      #main-content {
        display: none;
      }
    </style>


      <h2 id="sale-title"></h2>
  
      <div id="details" class="hidden" jstcache="0">
        <div class="suggestions" jsselect="suggestionsDetails" jstcache="4" jsinstance="*0" style="display: none;">
          <div class="suggestion-header" jsvalues=".innerHTML:header" jstcache="11"></div>
          <div class="suggestion-body" jsvalues=".innerHTML:body" jstcache="12"></div>
        </div>
      </div>

      <div id="main-frame-error" class="interstitial-wrapper">
        <div id="main-content"><div class="icon icon-offline" alt=""></div>
        <div class="runner-container" style="width: 201px; height: 150px;"><canvas class="runner-canvas" width="201" height="150" style="width: 201px; height: 150px;"></canvas></div>
      </div>
      
      <div id="main-content" jstcache="0">
        <img id="offline-resources-1x" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABMUAAABBCAMAAADmHuOOAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAJcEhZcwAABYkAAAWJAW1onfoAAAHOUExURUdwTCUlJVRUVFNTU/X19SQkJP///1JSUhQUEiYmJhQUExQUFCogHGZmZouLiy5wOkJCQhQTE6urq/f39xQSEiggHB4aGCIiIhsYFSkgHDg4OvPz8x4eHv////////////b29vT09Pf39/b29vf39wAAABQUFEFBQNnL0VNTU3o9BCYmJvf392ahLy5wO6zPNnBvGRQUExQTEyogHKWlperQsl5cYjsrKdW6oDk4Oh8fHfX09f///5ZyYCoqKFVCOXVWD2uIJDEtP41+eB8ZFycfHqcbLI+PjnRnWXdwcs6HkEtKTkQ9NmBJPoSEhHx8fN/FqYm4Mm2fOIp4ZyYmJ9rN0qWQfYBtXhkZGOnMrujJq0RDRW5tcFRTVTIyMnl5eTIlIldXV1RUVOfg45lvczY2NWdnZ1JRUbynlXx7fkhISUVCQxERESkfHURERDElIzQtMYl2ZYl0Y2ZlaS0mLTouKLWWgLpRXjQrJsB0f21scH56e5ycnCEhITs7OygoJyQkI5ubm+7q7CIiIj8xK0U0LYNzb4R0aHtdT6mbjzExMenOsEo7N11cW1taXIqJiSwrLIJ7fYyLjWZfWMLBwlFPU8d+iId5bVgSFOG+wyQd6QQAAAApdFJOUwC/QL+AQICAgIC/QICAgICAv4BAgECAgL+/gICAAQUGG0djOb8BgL+AiH0dXQAAEwxJREFUeNrsnfdzG8cVxw8AwUMRObSU2EmcnskkGLxfjgQhAiyZoSgJYhE1E5JqtmTJlm3JilMmsSPZTrHT4/T+32av3+6+t+XuAJIY7mgkYO+7iwOo+/D73r5bOM5ZO2tn7ayd+jYDijZT3uussXY875C9jwl0RJ1Yd6kHVG9TMaLebHa73SJ9rDWbdf5IkT6/nT8f/tsJWvDQ7XRcoS9+FB7y/3Y7UXO5o1IfdzR86iZC9+zin5J2AXodRevBhZIA5iOsbI6ZXejA3geMvSPuRLpLPaB8m+SIkEJNpK9bR/qaSF/cmjp9vUu+WFM8r/l5/++q26m5bq3jVhltaiFe0r70EUcx1sdaNavzmz+cGBtTrBpA0PVf7axNRYOOpoH6dz/XSIilD2dLPnmwv7rH0pH9LIH6kIsfoD9kUPy8FAzjIJbwqk4yTJiojrGt3jXm2Nxcar/cxEW5juC7iEfi2Pg5MSKmWOjQjuFi+1Ips3zj61/76lcmEpTNnBKIzfR0FOvNGAMQKCOWPpldK5tiWjdWmFGg7ZgYxYD+tUJTLIRKBenjeZX0ZbT1LtrSUZWuaiY+hqxIffNvvjkvksjNhnoKOgVeTJBHeDpminmZptM2MtqGU6babmaMBT0FxVxBe6zRudaK0VcNyBRDicJza212drbcszemGKAd7JzVCugADy2uAyZJMVXQSE5VIXnCd1cQs1XpEq2CWLUKgrGKgqfnP7z/8KOPHt7/8DxBsWocZcaP5LxY8CziWRyGYtFoyDM38XBjpBiDxsWkeY1GQ02ay4n2cqvRaDslqe1mDp2YRDGFGzvJFNu3oJgp8SSK+SArB2VAs1O+9CGlUKYjsHMqRWB/svjgOkC2cGZMCs96AhRTQqyCQqyrhVhmZBfFWMUEYzov5mYz/rzH4vyZwcoAvx4wVoo1vMXFDMbUdoxpM7DRmSYbtd3MRFRGuTEX0bonhmKwb0cx0Y8BltfPPvfpFUBsrcSzN6IYcBiKO8J3oVOQFOMjPAsmRQNLoZgSiEqIdXGIdfUQS1HUxTHWNcOYnBfjSMRfOG7KJCzKdIR/JNpNJqJsewwgQbt82eeZd04hbsXaxYs+dS5/7rNOSWq7mSOKMffFOTIVxUTtCaIYgrEiFJPWJGfJyBKsSgui9KMqkh0LxaAciqVWLifFwDEDohpidRxiTQOIJShq4hirm2EsXKPESBQFh2E4WU00ySpk3KemGKebCMXaCT1ChFy8uKRADadl3uk1JfIs1HYzJxTr+X8MKSZoTxLFZIzliijX1uLqCqJJdgysKgviWFLnxkCkGGgpBgqKiSHmcVEMDKdSJvbJJH5TldgXU/xNm7S/xNWwXowmkc0qJEaxiWf3Y4htLUXt4uUlLWpi7Wvf/945pxS13czTQ7FevLy6H1yevUIUM6oLW8u4sYhHhhRL1Ro3lknEA4chmmKYApQdk6dY9mWVU4lxIx8C1pG+VN/VNnosD0Hs9TkvRlSpIjWsYmzJj9VUzMYUG2fVq58VW1raWty6ucLazaUl9lSxEODTjil87Uow7JxTitpu5qmJKDNVIpzLyUkxk9fOujGjDBeiVp+lnkASxcyG6CnGcZU/QKCHHJGfYqo6sSxdmgiJmnqKNRGKNREyKurGwrxYGCmG64zxo7CG1Q0jwuRoJsKURiSHqPnCp9Vk6nFUvZ6LzA+D2LLfGEHohFTslFZWbvjaGzeXPq+Y2kZtN/O0ZPd7KcT2I4r1clKMOawAT7MmHOO8lUn1l6AGZZXH8VFMdSBT22EywgGwpVj8YaitWJOwYhVDKxbNXCHMWFNvxubnFxZiNzYlLaHYbzY3l5cvbW4umXBpc/PS8vLm5o+VfslGbTfztFAspVeYF9tPAWFJsdm12ZBOswZtTZoLzM9ZWF04ToqJy4RpAgs7gFGMHJG9QcGQYvHhnFasaWjFcKWVGZt79905ZzopFnmxZSOKhY5p+btmFDNQ2808RRTj1yjzU2w2k8DXNs5bGVGMV4Oy5taQYp2iFJOWCQXcWFCMGmFBsQSIaivWJaxYyJdu19SMNbuEGetqzNj8/Yf3nj699/B+dC8lFzZmwkessxoHorIYn4e7BrFwMg5GXcM5q/grvbi19au9vV8v3byxzFzQpU0lxba2tvb29hhrQuBpWJOq2bRsdpXaRjt9FNvv5KCY/k5K83VSsFOrx06IYiRIiAN5RuSgmHqBMjVIdYRidTOK1RGK1RGLRy1TJl4suSyEn2At7K1KF1E1OkpdXPR/oGqkqElzoquX1JxpP3dy7cXF76yv75lR7IXFxfX1dVPW2KjtZp4yiu13ClAs5xkIJFLfXy6pC1Is8zamjmKagLJJBJRd44ASt21N1WvxIWWSF3OJiyDY36JaEzHmhuyoIWTRX0vJWNeUYi5xIftrBjURh5/xKfa7T39rQjEnYM3eD8y8WKo2IJONdtoo1slFMav1RaPItKOrQDBX43arg6xygtqhkQcnQzGAkilWHzfF6iaJsbmILDXCNtXSf4SLqFrr5KGYjlZ2FAucnUyx9ffCfNTtO3f0FFuPUmh37vzIgGKGaruZMYr1FLtanKi7KE0pBtgegROhGEBRdeZEQe7IvBWUYkiRK8BxUAyyIjOK5UyLdc3TYrjWODHmJPuLqUlhE+VNmmKSvv2CH1NGFPvj7dsixb7MI8+nTcSa27d/qGaNjVqpnZH4hN0Lflp2tDCmGLkJTTYGzB1RcqVqajZaqjkkAdKBLnpSQ0BIvWOZ+TFRTL7fazooJtxHaU4Wda7KzUWxGuatqDnT2wQ6ck5qcf09RrG3L2nWKIM0GmOez5pLb+tXEm3UKi3zXQKjMk6sJ+wu5kqfpntS6EVUWqSbW6goBnarioV8mSJLpldzBAIH6RAmAs2QtLBCDkonS7HkZsrTTbGFhUyOycXIEm6nI9PNT5ZRelU9K0WxapDwr3aQ6BWdM+yvYZey78aStqUF008T7U9edMpTK7QCxWa4KnzRg1lQLLeVKTQUrXqNW4+mWBmRpEGmX+/LNGqJtTh8QTcEiPvFY5rkpRjkpli88ZlDT3UKKDY399JLgRvLEznWqk6ZEWUIMHrtkgyq5KP+/oTvXGPN311Mt6+Xv4mhr32npd6KLJi4Ya5WaUWK9VSRpEAxVxFJGm29jO8QXWAofgeSEK8Bv6eqFMoViCbHnusHcSzQFIvehWqIvOuF2g5pKIZEpSYUg4xJdOipToMXW7h3byFTMmGbq8pDMWrFIC7BqDnGFHOrHWxZov3o/uPh3w4P/3uo3+rVaT34+5ONw8M33rim35C14T16cP+XkdoroPUpFkeMM8LtkFJW345iwIECgQ6RTy8wFL0bnHdi6ZUCCnLAmN2YWd0FoqZzYPQG1fQQiWKa1JRixbEIxTJJv9NMsbmH9z55+vSTew/nAoAQkaMlxWraqtdaIJKL0BwHhRI1Z3AO6AjvQf+vw6uHz64cek/020o//pe38frhlWfXHh3oXduDx/2+r/72tYNBw1D77Jq0U2N45/eMWYWFm6GVpsKC+O3f4dYJ8TW5AkNNd6xO91SluDHW3JjC72nVAMLWglKHtPmgPER+q0UpRq0Q2FOMBOJpqLSIvVj41UedEiimr3qNVLUq5tNqquU4rF4MwZjX7w+HVz/+95WPvec6M9YY9O96G6uvX9n+4MlAs9Erm9dvvvrlDwbPv9U2025/MOgftBGK+Y4LWZssTjFq8Q0U9Cgw1Ipi6G/+6NoaN8XoXSuo3BhQjCrQgYArN8VENFpSLHPbE7lkevKrXpO82FQ1r7/BKLa6fWXV6+spdneDUWz1yvb1gZpijZBMd3/hq1++Pnj+pNU20rKZ+4MWl5+L/BdjFeLEetCTKJaux4oEc2WK6YkCFMVyDbWlGF7dcJwUI/Vjohg4ZVHMgQIUS3ZrzGyHdhrvQIrWKM8opqeY97N+3/OGG8OIYv0+ree0PsX6O4MDz0ty/DHFAHNi004xstYUJlJtYZhJE9Ulfv2kvEcOf1SotQPigLxOIo7QUIyvzwUn68JPz93gab3Y9FHsrX9aUOyqAcXa3s93fDINA/Xq9YOd/k4LH/BNXrt9/YBhrL/jrYw8dFFSU7PvKrRSpUUnT4NiQ8uh2Hgq2MxfQbP3//i/VZe0g6D7wMgkv7TXiJJiQuVf59TszDOVzafYX1bNKXZr1YBiraPRrsfIdCtQr15vtHb6ByN8XZPXbl9vtViEORitHLWMKDZDJga1904WQFERipl9q+6xUMx4pwzNN5QfF8XAYD0XzH5fcI5MQ7Hsi5z0XRKnl2JXLSg2NKHY7srKym7DG3rDiGJOq8/6PL12m2n9TNloZbc9dorlslRQcKgBAsE5LoqVOuE4KYZ+PmBiLMHIWINjSzGgXc/J2rF6Kik22NhgFPufT7FHOood/GFjg7HmfUaxPzcUqf3d0dERI9fQV2+/71Os7R2tjBo6rT9zIGq30nqLsVEsn6WCwkMvgNKN9eCCjpPjoVh5ubYJUAwvcEEckviuwORnCehSgIpioLI9J+rbQ6YRYqORt7Hxp6usef/5hwZiu6NdBhtf+9bu70mKfeHVfv8V36s1mDhUB/5q5Jlq+UbUV1B3gbs2FMthqaDw0LB4l2wz2pVDGBPFSp5wvBRzgIKVfgM09QiksE+bFwMBJSf4m9ymsLF47ujWMGi3ULOUpdgRi/1C7XC0Qoafjf5On/1hZIomHg6/6Nsr7CYkQityrEfn9o0p5toVGehRVGCoGQr0dVllQqdMNk6EYsIyoWNwgEOPxqA5xC3rGMW0zDhJ36o7da3d2h0xHoVtV0Mx5qZGR6NIfKSg2Cs7g8GrjEztRitSNxTEi7Te/9s7dx23YSCK0oANSdtskV8IUjj0Q8BiAXd2ncqLlMlX7P8DIfWmNKSGEinHq3srW3yIGpvHM/SIyu11rd4YvR9P4kMxpktFrGTPaDr9v8OIFAvu3MWmmB0k/gU09+QUio1gTNAYEwyMbYhgdEPEreuCmLh8vn/+1clZWi/uO7ar4K9mjf3G8VTnsP55T0V5p7mTYj+aui6KWb2x+RTjulTcfWr4NyRO9caCx5MRKCYGVxzlQECKWQokL9NCeGBsQ2NMjGNsQyypbdxnWAPExOWXzs1SZHpxocYI/vKyssvB+31RKm4jSvORrpu66QjF6IxXyd6jOvEP3Ii8eRms6XRvTIb/GshI/S6gyBTreICOfwUGXTkxtiMxlo1irAFRRkJst1aIicu7YsinoljKopgO/vKyMq//NGd1rVTEni8O4lF3H1n3d/WhmN2lkqPZnXOaTvPGInhi5i5AoJiFYsQOQ/bHJDiX+Hc+y/7cRfzdShf2C4rpgI5LsSL4C0yxdj2sCFMdFOt7Y3ZPbMixZNIyuhzN7pzTdJo3JiOhQD7pN3hBignrhrWU8Vx5YzviWPdgZssTM3mVEYhcWZ5Y6QHpeO7Cc5iq4C8wxdK8G0o66/a8MddO+34UE8SDzbjeyYymnt6YjBf3yWf1xJalmDAeITJCMSfHdsSxjOLdT3tZRvh5a2SYd9gnykX4wBSrV/bFGMVqb+xNvo1SrL0vPGFQrLuQJf0o1lsHC0WxLhoNihGOn1ixFqWY8KKYYkuWDZJN/Y5pCmW9eHDOMVAsHsXM+raq37bfF6HYVont97SNqq/7Nk7aQsNWAT0NxSBQzBJTvlW7O3MollSvEhYnOqsefhSrt2QtIrNIFHvy9StQDALFOhTbCurpbqEo1q4U8SPKYVZTYIq1bMWEAcWg/41iRH0nxap/JlkUSwavbFNBTl6Wj5ukUK+LVbv9P3FGBCgGxZXO2k9TzoPcNGd0tZzxIDfvrtvueRRzZlp4UWwGkBYAS2/feEwZC3pklAImxfCpPJxitYPF8JnSpm4euuu2e1ZEycm1SHqvPINDEalRSIqt+R9KKYxNo+WMAoNJ0vYIASvFJH5cQDFQjIoljXjXfAUVtjfS6eWMAhNvZYF0U4xoAUHj2jb7b21lb7/9EJNi0rYTAMtjfTHy1gjvgh7eqkMmxaRBMaIFBEHQHLdsXkEHbw2nOr9TdYPu7UfDFhAEQTPcsugF0v/kEARBEARBELScjoVeYYjQBoRhIWipOXhS+sBsC21AGBaClvIjTgelO2ZbWAPCsBC0nB9xOCvd1GzDdAtnwP/QsEcI+ppS/sJ5r3S93VXw09MrZsFkAzoNG1skxU4Q9DWl/IX9vpxth3uvzJgOr8fjB8zFN6DLsNFFUuwAQV9T1VTTs+1865X1fIjTHebiG9Bl2OgiKabj23JojcbeTiuK0Ymj4QPHfwh0CbDtDGN251ox3fQ6jq5wK4tNH6I62qs0eHvrFNhGEayTUFYaDoZ3seehAaueB8e9Rms5GesjVSIppkfSG/LY22lFMTpxNHzg+M+BLgG2nWFMc651Zty1rdvRlao0eHvtFNhGEayTUFYaDoZ3sXvepXqP1nmy8Y/USjEIgqCnECgGQRAoBkEQBIpBEASFo9g/faMdKN0Z+OMAAAAASUVORK5CYII=" jstcache="0">
        <img id="offline-resources-2x" src="data:image/png;base64,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" jstcache="0">
        <template id="audio-resources" jstcache="0">
          <audio id="offline-sound-reached" src="data:audio/mpeg;base64,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"></audio>
          <audio id="offline-sound-press" src="data:audio/mpeg;base64,SUQzBAAAAAAxIFRQRTQAAAAZAAADVmlvbGV0IChKZWZmZXJ5J3MgaU1hYykAVERSQwAAABIAAAMyMDE2LTA2LTE0IDExOjU3AFBSSVYAADA1AABYTVAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMTEgNzkuMTU4MzI1LCAyMDE1LzA5LzEwLTAxOjEwOjIwICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICB4bWxuczp4bXBETT0iaHR0cDovL25zLmFkb2JlLmNvbS94bXAvMS4wL0R5bmFtaWNNZWRpYS8iCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpiZXh0PSJodHRwOi8vbnMuYWRvYmUuY29tL2J3Zi9iZXh0LzEuMC8iCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6M2UzYjc4MDgtZWYwYy00NjE0LWE2MzAtOWVlMTc2NzhhYmRmIgogICB4bXBNTTpEb2N1bWVudElEPSI5NDU3OGE1My0wNzY4LWVmNGMtNWZhNC1mODVlMDAwMDAwNmYiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowZDdlM2U2ZC1lMGExLTRmMWItOTBjYS1hMmYzODc5YTk0OTUiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMTYtMDYtMTRUMTE6NTc6MzUtMDQ6MDAiCiAgIHhtcDpNb2RpZnlEYXRlPSIyMDE2LTA2LTE0VDExOjU3OjM1LTA0OjAwIgogICB4bXA6Q3JlYXRlRGF0ZT0iMjAxNi0wNi0xNFQxMTo1Nzo0NC0wNDowMCIKICAgeG1wOkNyZWF0b3JUb29sPSJTb3VuZCBGb3JnZSBQcm8gMS4wLjIyIChCdWlsZCAyKSIKICAgeG1wRE06ZW5naW5lZXI9IlZpb2xldCAoSmVmZmVyeSdzIGlNYWMpIgogICB4bXBETTphdWRpb1NhbXBsZVJhdGU9Ii0xIgogICB4bXBETTphdWRpb1NhbXBsZVR5cGU9IjE2SW50IgogICB4bXBETTphdWRpb0NoYW5uZWxUeXBlPSJTdGVyZW8iCiAgIHhtcERNOnN0YXJ0VGltZVNjYWxlPSIzMDAwMCIKICAgeG1wRE06c3RhcnRUaW1lU2FtcGxlU2l6ZT0iMTAwMSIKICAgZGM6Zm9ybWF0PSJNUDMiCiAgIGJleHQ6b3JpZ2luYXRvcj0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciBDQyAoTWEiCiAgIGJleHQ6b3JpZ2luYXRpb25EYXRlPSIyMDE2LTA2LTA5IgogICBiZXh0Om9yaWdpbmF0aW9uVGltZT0iMTU6NTk6MjIiCiAgIGJleHQ6dGltZVJlZmVyZW5jZT0iMCIKICAgYmV4dDp2ZXJzaW9uPSIxIj4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9ImM4ZjU3MGE2LTVkZTItMTVkYi0wM2NmLWMzNWQwMDAwMDA5YyIKICAgICAgc3RFdnQ6d2hlbj0iMjAxNi0wNi0xNFQxMTo1NzozNS0wNDowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciBDQyAoTWFjaW50b3NoKSIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0iY2JlMjZiZTktYzk5Mi1lMGY5LTFmNGEtZDI5MzAwMDAwMDgwIgogICAgICBzdEV2dDp3aGVuPSIyMDE2LTA2LTA5VDE1OjU5OjIyLTA0OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBBZG9iZSBNZWRpYSBFbmNvZGVyIENDIChNYWNpbnRvc2gpIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSI1NWNlYmQ2Yy1mOGFjLTVlOWMtZmVjZi1hNjlmMDAwMDAwODAiCiAgICAgIHN0RXZ0OndoZW49IjIwMTYtMDYtMDlUMTU6MjQ6MTYtMDQ6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIEFkb2JlIE1lZGlhIEVuY29kZXIgQ0MgKE1hY2ludG9zaCkiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MzA0NDUxOTAtMGIyMC00YmJhLTk2ZDgtMGIyZDk2MzcxNDVjIgogICAgICBzdEV2dDp3aGVuPSIyMDE2LTA2LTA5VDE1OjU5OjIyLTA0OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBBZG9iZSBNZWRpYSBFbmNvZGVyIENDIChNYWNpbnRvc2gpIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjIwOGJlNDdmLTJkMzktNDY1Ny1hNmY1LWYyNjhkODkxM2VmNCIKICAgICAgc3RFdnQ6d2hlbj0iMjAxNi0wNi0wOVQxNTo1OToyMi0wNDowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciBDQyAoTWFjaW50b3NoKSIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iL21ldGFkYXRhIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249Im1vZGlmaWVkIgogICAgICBzdEV2dDpwYXJhbWV0ZXJzPSJ1bmtub3duIG1vZGlmaWNhdGlvbnMiLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9IjIxOWQ3ODBiLWYyYzYtYzA2OS01NWJkLThmMGMwMDAwMDA5YyIKICAgICAgc3RFdnQ6d2hlbj0iMjAxNi0wNi0xNFQxMTo1MDo1NC0wNDowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciBDQyAoTWFjaW50b3NoKSIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDplMDg1MzA3OC05OTJjLTQ0MDMtOTk0Mi1jOWY0Mzg4YjA0NWIiCiAgICAgIHN0RXZ0OndoZW49IjIwMTYtMDYtMTRUMTE6NTc6MzUtMDQ6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIEFkb2JlIE1lZGlhIEVuY29kZXIgQ0MgKE1hY2ludG9zaCkiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6M2UzYjc4MDgtZWYwYy00NjE0LWE2MzAtOWVlMTc2NzhhYmRmIgogICAgICBzdEV2dDp3aGVuPSIyMDE2LTA2LTE0VDExOjU3OjM1LTA0OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBBZG9iZSBNZWRpYSBFbmNvZGVyIENDIChNYWNpbnRvc2gpIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvbWV0YWRhdGEiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogICA8eG1wTU06RGVyaXZlZEZyb20KICAgIHN0UmVmOmluc3RhbmNlSUQ9IjIxOWQ3ODBiLWYyYzYtYzA2OS01NWJkLThmMGMwMDAwMDA5YyIKICAgIHN0UmVmOmRvY3VtZW50SUQ9Ijg1NTliOGY2LTVkNjUtMWUzNy1hNGEzLWIyNTkwMDAwMDA2ZiIKICAgIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2N2Y3YmY3ZS00OWE5LTRkZjYtOWUyZS0zZTM4NWE0OTMxZDMiLz4KICAgPHhtcERNOmR1cmF0aW9uCiAgICB4bXBETTp2YWx1ZT0iMjciCiAgICB4bXBETTpzY2FsZT0iMTAwMS8zMDAwMCIvPgogICA8eG1wRE06c3RhcnRUaW1lY29kZQogICAgeG1wRE06dGltZUZvcm1hdD0iMjk5N0Ryb3BUaW1lY29kZSIKICAgIHhtcERNOnRpbWVWYWx1ZT0iMDA7MDA7MDA7MDAiLz4KICAgPHhtcERNOmFsdFRpbWVjb2RlCiAgICB4bXBETTp0aW1lVmFsdWU9IjAwOzAwOzAwOzAwIgogICAgeG1wRE06dGltZUZvcm1hdD0iMjk5N0Ryb3BUaW1lY29kZSIvPgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+AFRTU0UAAAAOAAADTGF2ZjYwLjMuMTAwAAAAAAAAAAAAAAD/+1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbmZvAAAADwAAAB0AACHAABERERkZGSIiIiIqKiozMzMzOzs7RERERExMTFVVVVVdXV1mZmZubm5ud3d3gICAgIiIiJGRkZGZmZmioqKiqqqqs7Ozu7u7u8TExMzMzMzV1dXd3d3d5ubm7u7u7vf39////wAAAABMYXZjNjAuMy4AAAAAAAAAAAAAAAAkAkAAAAAAAAAhwPFcp3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+1hkAARhpWOqkAFHEBjgBYIAAlwGLWzlIIBaAMGtXBQQCwsALk/+k/nl5iSaaGRtr8saeI4pP//dOhYkDkNhGDQuJ///tJa0mJurRJuniWHGP//91/LGIAA6f///////////Mmpp/aZNaAOyBCZr+ZDrIAAJAQNUv/g////sjGO////z/TyE/Tw4v+1Thz9vqf9T9XJpOd9Gn1P1OIy4glxAIDm8xol//IBAUBj+XMf//71f/4QAABbzgYGBn///zmJq+p+Rnz+5BfIoG5ORl1ER1QhIAE7ExxSY4a5//53///8HEHS3/////6mY6FH0KYYWhf0BmGEHSo4g4QE0chycOCKYYWR+PEfl0JYyxXN4fh0Kdz+NzP5Il8TQ4e//+1hkJgXzKWO7qOJ88kILd2UIAsILFZDsCYsTwICyHoAANjjS9NbbBbzzeQ4Grqcy3FrjE8HA4rhhQtjGJAADqQ7scrp//UhiB7KmxyL5v//yjp/+cilcAUzHEf//5BYIo4J9RugNwMIwsQHAhAtRQgDQY4JgAOGYDCDCwhhLgr4ki6yn1///////T//////9JfQ3v+hs0vqxW/ysb34Vx4g9AOPhynlSqQNCNIy5lj8xey3j/f03Ne7SHkJEzswoSrX39ZbWyW8IE2cU2k96sbHUgwyODU///rR/+pTmA9EB3kMkGrS9VH0n6kf+5IDWCvkNRgaGDApf////////4Vjh/pvUe/8sZBDg1AG4lzhLWdeIlkYyeFjLTXyr4xX/+1hEFA/yNWS9AgB8cD8sd9A0D45HMZD+BQExwO0x38CgLjnMDI8eU/TLSV03b1erkgsf/wVbaqQFtGMiQbeG+P44Q3////////+HkT/w2ff/hnIqPmx5oxi+UOiLpD0olf8PIiXV87ymsMCtck8seV/Gc7//1e77WSpxTw4YLyiYO/////////9E7/pqf/lyZfpEJhMUYNl2GY1X/EJsaCrCMQMb0yUPvwuLggTM71ydv+2hW00XHhhiw7///////zZb9VD/KycnyO4PZmP7yKRTp50/5KoiB+snh8LMC5Sakoy6JRIIMvvTN1/eq0e0yIQpBn5KBF////+Hmv//8sMXWtwWXX+WQl6b/6+kJFRDdIRN/mGn1QvnhkV+U/T/+1hkFI/iVGS+AaB8cCVsSDMABY5HmZEABoExwNmyHsQAv8i4mxGL4nDijczmNSlibH5WQCCNZN2COZjtND1pwqDyz4OgAAKCP///+ZBoocIBuLggS4gwpBuAjjBWUXCQwYUw76Hyigczziv////6Bn///+kAHKZ//OYwOG2+jXiQAC5wUqMWB2khmOWAzf90ETZpAxYNUrH4kOtjAW22liFoTgeIGHo////////yt9I4K6+EWXdWxf8nEeMWtddcHXPCfWfDtduaHHPDi/yHIqGoiGCJk+Ee4L5TImcE/////5f//0gYETht3/5w3LrjnIH8RZSiQwjGQf6ygozqKMZ6SCkiaPy2EDGd4jDYMaHm6Wa3FIILHx2nthJcT7j/+1hkIQ/hxWPAgUBMcCfMh/AAC54IIY7+BoFxwN+yX4gBP8hAkInf/cGTpN3EhCxQNjA3v0xBligtEdaS8B8cIvrhH///////mZa0Qhy3/IANva2TM9LW49joJ1nhCvMBqWkex2FJIJkDSRx2DtEBh/HYUj8IiwODw4LCaIYfF/+DY6YH///////+DjHauDq/ajlQlIuz3YEbJrH/+ansdKi6edeyrJCiHh63gsDjASmYtT1QtJJBNtc2qsAAAAAAjYf////9Q6K5W+rcaDdrKAI51chqhTCAgAwvcpgQsIDCnLMYNHVAAYH///////+QoQTkEX5suMj61ZAeTg9COZmezL8TDV0aZEApLBHfCKQtpatJwkpqrAMkroCADf//+1hkMgbhW17N0CAsfDSsh9IALPIFtXkYwoDx8KIyI0wAHj7//////x00xTwOoBEqC0uIADghFij4YBgQCKygOG4ljgr3EsEi/iwY4ICAD///7NiA55z/QNGlhaPHW+o3FwxmDw1G4lh0qD48mwInnDhBguZL1QAAIQAT////////QxAqXWg4Mky6DgiDBUJAVKC0mD8nEQJiYudQaOC4kZPcXjGpM8fJAmABgdZuo4MIUP/qOpMOMnDw/8wLigqoWokyIQBVPEwch5Tk0YIkTX4wohzcwLByifh3ILj+FyGwS5jq1w1//////////////++ogzkYYEzXuaKRC+h2UY4AapF2BIODsTJ/8QDSFET8A00LCB4wUaFIbYBqcUb/+1hkVI7hm2JBGUA8cDusZ9IADY5HKY0ABoExyMuxYQgAJjkP//+WyGf3vpSH//TBQR9Rj/3NJhIfpdcqBonDiaI7BACMY5//SMml6Z5WjZ+KsxwrxioOq////////////////////////KCXVZN6hNQ55xhzQuOEDSLc4m9xHEokdDLnkheGDigoFIXA80icn/////////////////0a0TZCKGY8d0FDmoo5CMwwXHI8aLMPhqiSDB9pGRnRhc+5w+IGU4mQToHTAAQAAQAYAIAoEAAAAABRwf1AtiPXQNAy2Jhrrfeow949BhDT78c5fJf/7hczBax7pf7/yOibmZ9Aul////dBk+gib/5NHEP4lh7/UsuBSrPnTcOekyL/+1hkZIAB1GPBBSjgADiseECgFAASSZj52RaAAlIzH0MU0ADoBOB8HOEURC3jBg3cXiKgS4BsBRhNih0w5IZwdTwvTOcCzE9KYDm4nADUAdAwIXgZYcJQGEDuF7EsHmWeThQeDQBzxaAqegh/LhX/jzMzIlP/wuBnJMvDk//8Shd0GLiP//+bm/zRb1hyyVJARsmlEFPDZAiRLgZsTA6dDiUYiciMD1FUCYl+F/HoM5KLUIICdFJESYbAhB5h/FwLgP4IWM5mFpC9CUBP+ZBFy4HIJckQ3yVColIaQ2hhg2eTBMgvARcT8bi4FUE5IYLcHJBbVf9Td50QjAQL+v4ZSQmIjgUd/8eHy3gbVJJ4BRhqsVsK247ycYPiGNEK+mH/+1hkFYADJWTVhm5AADSmyrDMqAAKPXddvYaACLSWbjeMUALqGLiIgQk2b/zA06jIPT/y4XEE06zMglakjIxJn/00/oNG2r1mRFW//oN6f+tSRwmP//////oI/pGv/GLEAs5/8y4iXo6x/tQd8jximBUFghHvJHiqRD74tpEYDTf/V/ip/v+h/0O///y3E3//iekgAAyhgkpUSmzjzK7DMtxuigTt8FQOrFRVeVS8masXnW1bKrMUUVDUCdDKSd0W//8xHqeLqP//+igXjb///qLxt///6Tot///1GSP///UXjYV60wHKAE7LaCVVXaq1mBkyONrFY0rf/y////M5v//+igKX/1hr/5IO//Bb/4aVLYBIGIZT0kH1xlCL8Qn/+1hkBwLiQzlMaYYTIDQC2X0N4zYEuY8IA4DTwKExoAAAJnlHIShYD4gC8oBQBFQvOiSLVXuUwUECUioLEO3/8xUVEOjt//6saZ1Z//9G5gwFIfqPCihz/9klW3/ERjS0CkOAAlYuwE5UB2cxYwzjvQCvmfSjlk1/+Gs2WocMMLEqS/X//////CRr9za0k+lfZQG1///Oc3/ZX4HmKqQPLTdgIgnCd8wMgr/9NxWDjjfwPmApifZTSGYEc8ICdHLZj0ZKMZ+uKz/EE+QjYPqFkIVA7EmRggBeNogoTt9NseoNxt////8Y/2u8Rpjn7ArQFhxFqcDHCpTEfDyOQL0WiJkCyjuOk7r3pEbeNmVrF2bNoU6Ra9J0XOmUM1jw1/H/+1hkH4/hWWRAgUBM8CfsiAAADJ4IRZL6BoHxwJOxoAQAHjunvL8WXrxoTWzxcJ6QYKUCOWUKLwRUW/////////////////L9scM/m4tmZWubM7S0OOsMDifspZUyhSeVlEQRSfW1iLIXFXnU0YHAo6tiElObJ0sTvKP///+Pj4nEcm9RWVbeo6bHGFZ7zjPYgN+ccayBgfAoFibypOcO////5APu/qUiHPYnMyIo/o2GBIMnQw9INDK8QskNYJpoo55ibnBeQ2+3gZ////1CYTxI4kDOIHPGg0YGBGWFpdQ2AeW1cERQSG/5lBhDj3FCrBr////////////8OlvwIAuPXyidk1D7cotHoV0gTXX48GzTYtqWta/pYmIKMOj/+1hkQI/hWWRAgUBM8CfMaEEAB47GBY8ABoFxwLSxIEgAs8jtNjQ////////w1ZOXemAuMTOcOZiSkU15pev1bWZhG3riqcTMyvPyV47YobOzRNUKt/////5xuEhzN///8N3/rp9p8rp9fD6NlOrvd/CHwLSJQZq8NEeYLAxzDOBSO8gR6R8bv+e8fG7px8nyg0bHgkaIWGGVvKiR+oacdKnuhgkGnwyBEMDpBGXFf//////////8h2YieWDc9+T7/hD3gGSBQxE7Svyz0MAaA53wEhHMGEGC4aQYC0WoIP1Ify+pn1GvKCU24k4ZnN6jc9hhR8+e4iI41PLIRHjkjRzyxEmNOCoO///////5AsgbQwqWJieVG3mD5UmTcVn/+1hkZg/hfWS9AkB88CqsOCEAB47GEZEABoERwKGxowgAHj1SojFhMGh2p8ZJINy8KF7IFhOQOHgsWKFFAAAKwPzSLfmtHSLeb6MfMZNBxqIH5EXvMEguYIrjwwSFDboOE5agfCDv//////+ZkdAXEXqXgw0BRgiF1KKh4cFg4GIIilSoFg+cXcQBABFIw4QUMGehAMtjxL7X2gq7/jeUsrKZcggRQlRtoVE/GJIolXaiMiA3zTFNgAAAAACJB////////nF3pHfHAUTKgendLSjCqsWnISqB8QFxdBXFqhwgAGh////////h58VKaElIcUy/zzbFv1FBFsSMzFjPHSpIHi7EW5co2inLl3SwIH////////GgMP4W3hiAiQj/+1hkig/himNBAUA8cihMCIMAB45FpY8GBQCxwJQxoEAAJnmAAQdLhiAogopxUOrBhAXkHu7oAIABAVGFJ///RsbiQzqGhua2I5ZBMG5mwY1OEsx1NNhE0cOLGiaVFJQy4oOPSaoCBX////////VBwhzDT9R4ixhkH7FBSdcVFTSp8IwywiurjcmFgegKCQuJheG0KgAMH/////+DdAfFRFQuMmtXbuLCBEAnFO0cM+esGhELf+1/SMmnnXirTfSbdLAi////////////9M3H8y/MBKCefxCH8htIQao1HSoEoT+O8QZ4URoyaO217FBw6DYxYYGR4wMBeAePBYb2T//////Xo/OPDEqIAHMAZtdEdQsgGDwbFBfKCjSLRCP/+1hksgbhTWPM0CAsfCzMaDIASfJFQY0eoQCx+KMwYYgAHjgb+mJKBmKgGs9xiSn4WvPznZRiAAlB////////////+RQuH8lu9IPR0jyDICQ17i56yJ9xetZYBYPDO4IdcMQWHsdAfh1hiZPJw8DYBOFYsNmrWAABSB///////nOp4CQDTawnJhmgE8RzNvwmxkLw+3IUsbKvcu2RPBe+Oxoiav/w+foPn40+VAVCSABj////////////////8sKGM5fHkSBKzq6NnkwSDE4GCVyIIYpnAupgR1Gli+LN9rg/k5AKIpCSwldIU5mLabLghJh2b2j///////FAkCIDsmTzMzca2HsWV8cwaD7jFLfJJR6C62xg4FocE8nuzOH/+1hk2w/hd2LAiaA8di3MCFIAqfIHqZL8BoFx0Mux4EQDp8jDns2xcTxHO4dWCQAMABh////////////yRDYqD6SBOLxFDYkFnkoC4mLHWN5EEwgCiGh6JKQCJ8+QRBh6LaBLQVHeCEXAEGZJHcFTEz84Hf//////5EB2iEEEIoJj/9iQvYv5Bg/WNdtz2oiz1+p0LPtpawCNBLQkQ6KRyABco/X5Kz6//5eEyZYjAb4hxot9EAyP////////////////+dKZDnz4N0mKHGUfXxMMIn7frsqtUKcHXoRcvL1W0E6DCEkLcbLHqC90QlV7DKZjvFnMNvFMW4aaKT///////MHgGDpS5nDimbOnI6DMdpTmesjMrl4cY9LBBIT/+1hk8o7h/WTGkEBcfDisV+MA7/JIxYr4SAHx2NaxoMQDs82ctgTLhRaemZZWHnUnIyjH1EUFBn/////Ihja52ZEJaDgm5MyaNqXfkbmlT7S+HtDi63QeyTIaoS8t1WN2fh2Jyf6XZbA6B25O5ZT9KcJEysCGTbYXUFhmLMXDMofhBy/kAQyyugKk4jS2DIL0W9H1wwHuQ8NWhgKKPONFbH/tMATosUxAAVFf////8lwSFpyMM4CQFjAn4RwHyP58IrOhjQUJD8YvfXagU4br6hMha8hdgxi+jCD8VzYhidLscLJdKNghA////////wIKDRsloHy2CA6/kFVbClUMwpyCOsHwLoOwLdIEoEdKZWB8K58ZIjc+CGr4WhJEGn3/+1hk9o7iHWM+kaBcdkKsl9EBr/KI+ZDyKYHx0Nax4EgCs8gX8lYirVjBd0eqCv////8SstLaYZjqBuKoTsgZYYz9ykEXikIMp5PAQxklZ3ch+JdiZtmCM5BE8HeKOON051eJ8sR1E9AA5P///////8QC4nW1nKPBskOdVw2fET/6axakMHIOk4SBBviYhxKocwyHyEBHy9b9uYRylSREBUEKOBgi5e2Cov////yGgwuYrEMq4A3TLhoay5PUDUD5J6ToWJQCLCdt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nWSsYAWeSKiyFogAHjgwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+1hkgY/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo="></audio>
        </template>
      </div>

      <script>
        (function() {
            'use strict';
            /**
            * RunnerKRTV.
            * @param {string} outerContainerId Outer containing element id.
            * @param {Object} opt_config
            * @constructor
            * @export
            */
            function Runner(outerContainerId, opt_config) {
              // Singleton
              if (Runner.instance_) {
                return Runner.instance_;
              }
              Runner.instance_ = this;
              this.outerContainerEl = document.querySelector(outerContainerId);
              this.containerEl = null;
              this.snackbarEl = null;
              this.config = opt_config || Runner.config;
              // Logical dimensions of the container.
              this.dimensions = Runner.defaultDimensions;
              this.canvas = null;
              this.canvasCtx = null;
              this.tRex = null;
              this.distanceMeter = null;
              this.distanceRan = 0;
              this.highestScore = 0;
              this.time = 0;
              this.runningTime = 0;
              this.msPerFrame = 1000 / FPS;
              this.currentSpeed = this.config.SPEED;
              this.obstacles = [];
              this.activated = false; // Whether the   has been activated.
              this.playing = false; // Whether the game is currently in play state.
              this.crashed = false;
              this.paused = false;
              this.inverted = false;
              this.invertTimer = 0;
              this.resizeTimerId_ = null;
              this.playCount = 0;
              // Sound FX.
              this.audioBuffer = null;
              this.soundFx = {};
              // Global web audio context for playing sounds.
              this.audioContext = null;
              // Images.
              this.images = {};
              this.imagesLoaded = 0;
              if (this.isDisabled()) {
                this.setupDisabledRunner();
              } else {
                this.loadImages();
              }
            }
            window['Runner'] = Runner;
            /**
            * Default game width.
            * @const
            */
            var DEFAULT_WIDTH = 600;
            /**
            * Frames per second.
            * @const
            */
            var FPS = 60;
            /** @const */
            var IS_HIDPI = window.devicePixelRatio > 1;
            /** @const */
            var IS_IOS = /iPad|iPhone|iPod/.test(window.navigator.platform);
            /** @const */
            var IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;
            /** @const */
            var IS_TOUCH_ENABLED = 'ontouchstart' in window;
            /** @const */
            var ARCADE_MODE_URL = '/';
            /**
            * Default game configuration.
            */
            Runner.config = {
              ACCELERATION: 0.001,
              BG_CLOUD_SPEED: 0.2,
              BOTTOM_PAD: 10,
              // Scroll Y threshold at which the game can be activated.
              CANVAS_IN_VIEW_OFFSET: -10,
              CLEAR_TIME: 3000,
              CLOUD_FREQUENCY: 0.5,
              GAMEOVER_CLEAR_TIME: 750,
              GAP_COEFFICIENT: 0.6,
              GRAVITY: 0.6,
              INITIAL_JUMP_VELOCITY: 12,
              INVERT_FADE_DURATION: 12000,
              INVERT_DISTANCE: 700,
              MAX_BLINK_COUNT: 3,
              MAX_CLOUDS: 6,
              MAX_OBSTACLE_LENGTH: 3,
              MAX_OBSTACLE_DUPLICATION: 2,
              MAX_SPEED: 13,
              MIN_JUMP_HEIGHT: 35,
              MOBILE_SPEED_COEFFICIENT: 1.2,
              RESOURCE_TEMPLATE_ID: 'audio-resources',
              SPEED: 6,
              SPEED_DROP_COEFFICIENT: 3,
              ARCADE_MODE_INITIAL_TOP_POSITION: 35,
              ARCADE_MODE_TOP_POSITION_PERCENT: 0.1
            };
            /**
            * Default dimensions.
            * @enum {string}
            */
            Runner.defaultDimensions = {
              WIDTH: DEFAULT_WIDTH,
              HEIGHT: 150
            };
            /**
            * CSS class names.
            * @enum {string}
            */
            Runner.classes = {
              ARCADE_MODE: 'arcade-mode',
              CANVAS: 'runner-canvas',
              CONTAINER: 'runner-container',
              CRASHED: 'crashed',
              ICON: 'icon-offline',
              INVERTED: 'inverted',
              SNACKBAR: 'snackbar',
              SNACKBAR_SHOW: 'snackbar-show',
              TOUCH_CONTROLLER: 'controller'
            };
            /**
            * Sprite definition layout of the spritesheet.
            * @enum {Object}
            */
            Runner.spriteDefinition = {
              LDPI: {
                CACTUS_LARGE: {x: 332, y: 2},
                CACTUS_SMALL: {x: 228, y: 2},
                CLOUD: {x: 86, y: 2},
                HORIZON: {x: 2, y: 54},
                MOON: {x: 484, y: 2},
                PTERODACTYL: {x: 134, y: 2},
                RESTART: {x: 2, y: 2},
                TEXT_SPRITE: {x: 655, y: 2},
                TREX: {x: 848, y: 2},
                STAR: {x: 645, y: 2}
              },
              HDPI: {
                CACTUS_LARGE: {x: 652, y: 2},
                CACTUS_SMALL: {x: 446, y: 2},
                CLOUD: {x: 166, y: 2},
                HORIZON: {x: 2, y: 104},
                MOON: {x: 954, y: 2},
                PTERODACTYL: {x: 260, y: 2},
                RESTART: {x: 2, y: 2},
                TEXT_SPRITE: {x: 1294, y: 2},
                TREX: {x: 1678, y: 2},
                STAR: {x: 1276, y: 2}
              }
            };
            /**
            * Sound FX. Reference to the ID of the audio tag on interstitial page.
            * @enum {string}
            */
            Runner.sounds = {
              BUTTON_PRESS: 'offline-sound-press',
              //HIT: 'offline-sound-hit',
              SCORE: 'offline-sound-reached'
            };
            /**
            * Key code mapping.
            * @enum {Object}
            */
            Runner.keycodes = {
              JUMP: {'38': 1, '32': 1, '87': 1},  // Up, spacebar
              DUCK: {'40': 1, '83': 1},  // Down
              RESTART: {'13': 1}  // Enter
            };
            /**
            * Runner event names.
            * @enum {string}
            */
            Runner.events = {
              ANIM_END: 'webkitAnimationEnd',
              CLICK: 'click',
              KEYDOWN: 'keydown',
              KEYUP: 'keyup',
              MOUSEDOWN: 'mousedown',
              MOUSEUP: 'mouseup',
              RESIZE: 'resize',
              TOUCHEND: 'touchend',
              TOUCHSTART: 'touchstart',
              VISIBILITY: 'visibilitychange',
              BLUR: 'blur',
              FOCUS: 'focus',
              LOAD: 'load'
            };
            
                Runner.prototype = {
                    /**
                    * Whether the   has been disabled. CrOS enterprise enrolled devices.
                    * @return {boolean}
                    */
                    isDisabled: function () {
                        // return loadTimeData && loadTimeData.valueExists('disabled');
                        return false;
                    },

              /**
              * For disabled instances, set up a snackbar with the disabled message.
              */
              setupDisabledRunner: function() {
                this.containerEl = document.createElement('div');
                this.containerEl.className = Runner.classes.SNACKBAR;
                this.containerEl.textContent = loadTimeData.getValue('disabled');
                this.outerContainerEl.appendChild(this.containerEl);
                // Show notification when the activation key is pressed.
                document.addEventListener(Runner.events.KEYDOWN, function(e) {
                  if (Runner.keycodes.JUMP[e.keyCode]) {
                    this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);
                    document.querySelector('.icon').classList.add('icon-disabled');
                  }
                }.bind(this));
              },
              
              /**
              * Setting individual settings for debugging.
              * @param {string} setting
              * @param {*} value
              */
              updateConfigSetting: function(setting, value) {
                if (setting in this.config && value != undefined) {
                  this.config[setting] = value;
                  switch (setting) {
                    case 'GRAVITY':
                    case 'MIN_JUMP_HEIGHT':
                    case 'SPEED_DROP_COEFFICIENT':
                      this.tRex.config[setting] = value;
                      break;
                    case 'INITIAL_JUMP_VELOCITY':
                      this.tRex.setJumpVelocity(value);
                      break;
                    case 'SPEED':
                      this.setSpeed(value);
                      break;
                  }
                }
              },
              
              /**
              * Cache the appropriate image sprite from the page and get the sprite sheet
              * definition.
              */
              loadImages: function() {
                if (IS_HIDPI) {
                  Runner.imageSprite = document.getElementById('offline-resources-2x');
                  this.spriteDef = Runner.spriteDefinition.HDPI;
                } else {
                  Runner.imageSprite = document.getElementById('offline-resources-1x');
                  this.spriteDef = Runner.spriteDefinition.LDPI;
                }
                if (Runner.imageSprite.complete) {
                  this.init();
                } else {
                  // If the images are not yet loaded, add a listener.
                  Runner.imageSprite.addEventListener(Runner.events.LOAD,
                      this.init.bind(this));
                }
              },
              /**
              * Load and decode base 64 encoded sounds.
              */
              loadSounds: function() {
                if (!IS_IOS) {
                  this.audioContext = new AudioContext();
                  var resourceTemplate =
                      document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;
                  for (var sound in Runner.sounds) {
                    var soundSrc =
                        resourceTemplate.getElementById(Runner.sounds[sound]).src;
                    soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);
                    var buffer = decodeBase64ToArrayBuffer(soundSrc);
                    // Async, so no guarantee of order in array.
                    this.audioContext.decodeAudioData(buffer, function(index, audioData) {
                        this.soundFx[index] = audioData;
                      }.bind(this, sound));
                  }
                }
              },
            
              /**
              * Sets the game speed. Adjust the speed accordingly if on a smaller screen.
              * @param {number} opt_speed
              */
              setSpeed: function(opt_speed) {
                var speed = opt_speed || this.currentSpeed;
                // Reduce the speed on smaller mobile screens.
                if (this.dimensions.WIDTH < DEFAULT_WIDTH) {
                  var mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH *
                      this.config.MOBILE_SPEED_COEFFICIENT;
                  this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;
                } else if (opt_speed) {
                  this.currentSpeed = opt_speed;
                }
              },
            
              /**
              * Game initialiser.
              */
              init: function() {
                // Hide the static icon.
                document.querySelector('.' + Runner.classes.ICON).style.visibility =
                    'hidden';
                this.adjustDimensions();
                this.setSpeed();
                this.containerEl = document.createElement('div');
                this.containerEl.className = Runner.classes.CONTAINER;
                // Player canvas container.
                this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,
                    this.dimensions.HEIGHT, Runner.classes.PLAYER);
                this.canvasCtx = this.canvas.getContext('2d');
                this.canvasCtx.fillStyle = '#f7f7f7';
                this.canvasCtx.fill();
                Runner.updateCanvasScaling(this.canvas);
                // Horizon contains clouds, obstacles and the ground.
                this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,
                    this.config.GAP_COEFFICIENT);
                // Distance meter
                this.distanceMeter = new DistanceMeter(this.canvas,
                      this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);
                // Draw RunnerKRTV
                this.tRex = new Trex(this.canvas, this.spriteDef.TREX);
                this.outerContainerEl.appendChild(this.containerEl);
                if (IS_MOBILE) {
                  this.createTouchController();
                }
                this.startListening();
                this.update();
                window.addEventListener(Runner.events.RESIZE,
                    this.debounceResize.bind(this));
              },
              /**
              * Create the touch controller. A div that covers whole screen.
              */
              createTouchController: function() {
                this.touchController = document.createElement('div');
                this.touchController.className = Runner.classes.TOUCH_CONTROLLER;
              },
              /**
              * Debounce the resize event.
              */
              debounceResize: function() {
                if (!this.resizeTimerId_) {
                  this.resizeTimerId_ =
                      setInterval(this.adjustDimensions.bind(this), 250);
                }
              },
              /**
              * Adjust game space dimensions on resize.
              */
              adjustDimensions: function() {
                clearInterval(this.resizeTimerId_);
                this.resizeTimerId_ = null;
                var boxStyles = window.getComputedStyle(this.outerContainerEl);
                var padding = Number(boxStyles.paddingLeft.substr(0,
                    boxStyles.paddingLeft.length - 2));
                this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;
                this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);
                    
                    
                // Redraw the elements back onto the canvas.
                if (this.canvas) {
                  this.canvas.width = this.dimensions.WIDTH;
                  this.canvas.height = this.dimensions.HEIGHT;
                  Runner.updateCanvasScaling(this.canvas);
                  this.distanceMeter.calcXPos(this.dimensions.WIDTH);
                  this.clearCanvas();
                  this.horizon.update(0, 0, true);
                  this.tRex.update(0);
                  // Outer container and distance meter.
                  if (this.playing || this.crashed || this.paused) {
                    this.containerEl.style.width = this.dimensions.WIDTH + 'px';
                    this.containerEl.style.height = this.dimensions.HEIGHT + 'px';
                    this.distanceMeter.update(0, Math.ceil(this.distanceRan));
                    this.stop();
                  } else {
                    this.tRex.draw(0, 0);
                  }
                  // Game over panel.
                  if (this.crashed && this.gameOverPanel) {
                    
                    this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);
                    this.gameOverPanel.draw();
                  }
                }
              },
            
              /**
              * Play the game intro.
              * Canvas container width expands out to the full width.
              */
              playIntro: function() {
                if (!this.activated && !this.crashed) {
                  this.playingIntro = true;
                  this.tRex.playingIntro = true;
                  // CSS animation definition.
                  var keyframes = '@-webkit-keyframes intro { ' +
                        'from { width:' + Trex.config.WIDTH + 'px }' +
                        'to { width: ' + this.dimensions.WIDTH + 'px }' +
                      '}';
                  document.styleSheets[0].insertRule(keyframes, 0);
                  this.containerEl.addEventListener(Runner.events.ANIM_END,
                      this.startGame.bind(this));
                  this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';
                  this.containerEl.style.width = this.dimensions.WIDTH + 'px';
                  if (this.touchController) {
                    this.outerContainerEl.appendChild(this.touchController);
                  }
                  this.playing = true;
                  this.activated = true;
                } else if (this.crashed) {
                  this.restart();
                }
              },
            
            
                    /**
                    * Update the game status to started.
                    */
                    startGame: function () {
                        this.isArcadeMode = 1;
                        this.setArcadeMode = false;
                        this.runningTime = 0;
                        this.playingIntro = false;
                        this.tRex.playingIntro = false;
                        this.containerEl.style.webkitAnimation = '';
                        this.playCount++;
            
                // Handle tabbing off the page. Pause the current game.
                document.addEventListener(Runner.events.VISIBILITY,
                      this.onVisibilityChange.bind(this));
                window.addEventListener(Runner.events.BLUR,
                      this.onVisibilityChange.bind(this));
                window.addEventListener(Runner.events.FOCUS,
                      this.onVisibilityChange.bind(this));
              },
              clearCanvas: function() {
                this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,
                    this.dimensions.HEIGHT);
              },
              
              /**
              * Update the game frame and schedules the next one.
              */
              update: function() {
                this.updatePending = false;
                var now = getTimeStamp();
                var deltaTime = now - (this.time || now);
                this.time = now;
                if (this.playing) {
                  this.clearCanvas();
                  if (this.tRex.jumping) {
                    this.tRex.updateJump(deltaTime);
                  }
                  this.runningTime += deltaTime;
                  var hasObstacles = this.runningTime > this.config.CLEAR_TIME;
                  // First jump triggers the intro.
                  if (this.tRex.jumpCount == 1 && !this.playingIntro) {
                    this.playIntro();
                  }
                  // The horizon doesn't move until the intro is over.
                  if (this.playingIntro) {
                    this.horizon.update(0, this.currentSpeed, hasObstacles);
                  } else {
                    deltaTime = !this.activated ? 0 : deltaTime;
                    this.horizon.update(deltaTime, this.currentSpeed, hasObstacles,
                        this.inverted);
                  }
                  // Check for collisions.
                  var collision = hasObstacles &&
                      checkForCollision(this.horizon.obstacles[0], this.tRex);
                  if (!collision) {
                    this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;
                    if (this.currentSpeed < this.config.MAX_SPEED) {
                      this.currentSpeed += this.config.ACCELERATION;
                    }
                  } else {
                    this.gameOver();/* */
                  }
                  var playAchievementSound = this.distanceMeter.update(deltaTime,
                      Math.ceil(this.distanceRan));
                  if (playAchievementSound) {
                    this.playSound(this.soundFx.SCORE);
                  }
            
                  //  
                  if (this.invertTimer > this.config.INVERT_FADE_DURATION) {
                    this.invertTimer = 0;
                    this.invertTrigger = false;
                    this.invert();
                  } else if (this.invertTimer) {
                    this.invertTimer += deltaTime;
                  } else {
                    var actualDistance =
                        this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));
                    if (actualDistance > 0) {
                      this.invertTrigger = !(actualDistance %
                          this.config.INVERT_DISTANCE);
                      if (this.invertTrigger && this.invertTimer === 0) {
                        this.invertTimer += deltaTime;
                        //this.invert();
                      }
                    }
                  }
                }
                if (this.playing || (!this.activated &&
                    this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {
                  this.tRex.update(deltaTime);
                  this.scheduleNextUpdate();
                }
              },
                            
              /**
              * Event handler.
              */
              handleEvent: function(e) {
                return (function(evtType, events) {
                  switch (evtType) {
                    case events.KEYDOWN:
                    case events.TOUCHSTART:
                    case events.MOUSEDOWN:
                      this.onKeyDown(e);
                      break;
                    case events.KEYUP:
                    case events.TOUCHEND:
                    case events.MOUSEUP:
                      this.onKeyUp(e);
                      break;
                  }
                }.bind(this))(e.type, Runner.events);
              },	
              
              /**
              * Bind relevant key / mouse / touch listeners.
              */
              startListening: function() {
                // Keys.
                document.addEventListener(Runner.events.KEYDOWN, this);
                document.addEventListener(Runner.events.KEYUP, this);
                if (IS_MOBILE) {
                  // Mobile only touch devices.
                  this.touchController.addEventListener(Runner.events.TOUCHSTART, this);
                  this.touchController.addEventListener(Runner.events.TOUCHEND, this);
                  this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);
                } else {
                  // Mouse.
                  document.addEventListener(Runner.events.MOUSEDOWN, this);
                  document.addEventListener(Runner.events.MOUSEUP, this);
                }
              },
            
              /**
              * Remove all listeners.
              */
              stopListening: function() {
                document.removeEventListener(Runner.events.KEYDOWN, this);
                document.removeEventListener(Runner.events.KEYUP, this);
                if (IS_MOBILE) {
                  this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);
                  this.touchController.removeEventListener(Runner.events.TOUCHEND, this);
                  this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);
                } else {
                  document.removeEventListener(Runner.events.MOUSEDOWN, this);
                  document.removeEventListener(Runner.events.MOUSEUP, this);
                }
              },
              /**
              * Process keydown.
              * @param {Event} e
              */
              onKeyDown: function(e) {
                // Prevent native page scrolling whilst tapping on mobile.
                if (IS_MOBILE && this.playing) {
                  e.preventDefault();
                }
                if (!this.crashed && !this.paused) {
                  if (Runner.keycodes.JUMP[e.keyCode] ||
                      e.type == Runner.events.TOUCHSTART) {
                    e.preventDefault();
                    // Starting the game for the first time.
                    if (!this.playing) {
                      this.loadSounds();
                      this.playing = true;
                      this.update();
                      if (window.errorPageController) {
                        errorPageController.track();
                      }
                    }
                    // Start jump.
                    if (!this.tRex.jumping && !this.tRex.ducking) {
                      this.playSound(this.soundFx.BUTTON_PRESS);
                      this.tRex.startJump(this.currentSpeed);
                    }
                  } else if (this.playing && Runner.keycodes.DUCK[e.keyCode]) {
                    e.preventDefault();
                    if (this.tRex.jumping) {
                      // Speed drop, activated only when jump key is not pressed.
                      this.tRex.setSpeedDrop();
                    } else if (!this.tRex.jumping && !this.tRex.ducking) {
                      // Duck.
                      this.tRex.setDuck(true);
                    }
                  }
                } else if (this.crashed && e.type == Runner.events.TOUCHSTART &&
                    e.currentTarget == this.containerEl) {
                  this.restart();
                }
              },
            
            
                    /**
                    * Process keydown.
                    * @param {Event} e
                    */
                    onKeyDown: function (e) {
                        // Prevent native page scrolling whilst tapping on mobile.
                        if (IS_MOBILE && this.playing) {
                            e.preventDefault();
                        }
            
                        if (e.target != this.detailsButton) {
                            if (!this.crashed && (Runner.keycodes.JUMP[e.keyCode] ||
                                e.type == Runner.events.TOUCHSTART)) {
                                if (!this.playing) {
                                    this.loadSounds();
                                    this.playing = true;
                                    this.update();
                                    if (window.errorPageController) {
                                        errorPageController.track();
                                    }
                                }
                                //  Play sound effect and jump on starting the game for the first time.
                                if (!this.tRex.jumping && !this.tRex.ducking) {
                                    this.playSound(this.soundFx.BUTTON_PRESS);
                                    this.tRex.startJump(this.currentSpeed);
                                }
                            }
            
                            if (this.crashed && e.type == Runner.events.TOUCHSTART &&
                                e.currentTarget == this.containerEl) {
                                this.restart();
                            }
                        }
            
                        if (this.playing && !this.crashed && Runner.keycodes.DUCK[e.keyCode]) {
                            e.preventDefault();
                            if (this.tRex.jumping) {
                                // Speed drop, activated only when jump key is not pressed.
                                this.tRex.setSpeedDrop();
                            } else if (!this.tRex.jumping && !this.tRex.ducking) {
                                // Duck.
                                this.tRex.setDuck(true);
                            }
                        }
                    },
            
            
              /**
              * Process keydown.
              * @param {Event} e
              */
              onKeyDown: function(e) {
                // Prevent native page scrolling whilst tapping on mobile.
                if (IS_MOBILE && this.playing) {
                  e.preventDefault();
                }
                if (!this.crashed && !this.paused) {
                  if (Runner.keycodes.JUMP[e.keyCode] ||
                      e.type == Runner.events.TOUCHSTART) {
                    e.preventDefault();
                    // Starting the game for the first time.
                    if (!this.playing) {
                      this.loadSounds();
                      this.playing = true;
                      this.update();
                      if (window.errorPageController) {
                        errorPageController.track();
                      }
                    }
                    // Start jump.
                    if (!this.tRex.jumping && !this.tRex.ducking) {
                      this.playSound(this.soundFx.BUTTON_PRESS);
                      this.tRex.startJump(this.currentSpeed);
                    }
                  } else if (this.playing && Runner.keycodes.DUCK[e.keyCode]) {
                    e.preventDefault();
                    if (this.tRex.jumping) {
                      // Speed drop, activated only when jump key is not pressed.
                      this.tRex.setSpeedDrop();
                    } else if (!this.tRex.jumping && !this.tRex.ducking) {
                      // Duck.
                      this.tRex.setDuck(true);
                    }
                  }
                } else if (this.crashed && e.type == Runner.events.TOUCHSTART &&
                    e.currentTarget == this.containerEl) {
                  this.restart();
                }
              },
              /**
              * Process key up.
              * @param {Event} e
              */
              onKeyUp: function(e) {
                var keyCode = String(e.keyCode);
                var isjumpKey = Runner.keycodes.JUMP[keyCode] ||
                  e.type == Runner.events.TOUCHEND ||
                  e.type == Runner.events.MOUSEDOWN;
                if (this.isRunning() && isjumpKey) {
                  this.tRex.endJump();
                } else if (Runner.keycodes.DUCK[keyCode]) {
                  this.tRex.speedDrop = false;
                  this.tRex.setDuck(false);
                } else if (this.crashed) {
                  // Check that enough time has elapsed before allowing jump key to restart.
                  var deltaTime = getTimeStamp() - this.time;
                  if (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||
                      (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&
                      Runner.keycodes.JUMP[keyCode])) {
                    this.restart();
                  }
                } else if (this.paused && isjumpKey) {
                  // Reset the jump state
                  this.tRex.reset();
                  this.play();
                }
              },
              /**
              * Returns whether the event was a left click on canvas.
              * On Windows right click is registered as a click.
              * @param {Event} e
              * @return {boolean}
              */
              isLeftClickOnCanvas: function(e) {
                return e.button != null && e.button < 2 &&
                    e.type == Runner.events.MOUSEUP && e.target == this.canvas;
              },
              /**
              * RequestAnimationFrame wrapper.
              */
              scheduleNextUpdate: function() {
                if (!this.updatePending) {
                  this.updatePending = true;
                  this.raqId = requestAnimationFrame(this.update.bind(this));
                }
              },
              /**
              * Whether the game is running.
              * @return {boolean}
              */
              isRunning: function() {
                return !!this.raqId;
              },
              /**
              * Game over state.
              */
              gameOver: function() {
                //this.playSound(this.soundFx.HIT);
                vibrate(200);
                this.stop();
                this.crashed = true;
                this.distanceMeter.acheivement = false;
                
                this.tRex.update(100, Trex.status.CRASHED);
                
                // Game over panel.
                if (!this.gameOverPanel) {
                  this.gameOverPanel = new GameOverPanel(this.canvas,
                  this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART,
                  this.dimensions);
                } else {
                  this.gameOverPanel.draw();
                }
                
                if (this.gameOverPanel) {
                  
                  let saleValue =  calculateSale(arrayToNumber(this.distanceMeter['digits']));
                  var message = {
                    state: 'gameover',
                    sale: saleValue,
                  };
                  window.parent.postMessage(message, "/");
                  console.log('game over!' + saleValue);
                  
                }
                // Update the high score.
                if (this.distanceRan > this.highestScore) {
                  this.highestScore = Math.ceil(this.distanceRan);
                  this.distanceMeter.setHighScore(this.highestScore);
                }
                // Reset the time clock.
                this.time = getTimeStamp();
              },
              stop: function() {
                this.playing = false;
                this.paused = true;
                cancelAnimationFrame(this.raqId);
                this.raqId = 0;
              },
              play: function() {
                if (!this.crashed) {
                  this.playing = true;
                  this.paused = false;
                  this.tRex.update(0, Trex.status.RUNNING);
                  this.time = getTimeStamp();
                  this.update();
                }
              },
              restart: function() {
                if (!this.raqId) {
                  this.playCount++;
                  this.runningTime = 0;
                  this.playing = true;
                  this.paused = false;
                  this.crashed = false;
                  this.distanceRan = 0;
                  this.setSpeed(this.config.SPEED);
                  this.time = getTimeStamp();
                  this.containerEl.classList.remove(Runner.classes.CRASHED);
                  this.clearCanvas();
                  this.distanceMeter.reset(this.highestScore);
                  this.horizon.reset();
                  this.tRex.reset();
                  this.playSound(this.soundFx.BUTTON_PRESS);
                  this.invert(false);//
                  this.update();
                }
              },
              /**
              * Pause the game if the tab is not in focus.
              */
              onVisibilityChange: function(e) {
                if (document.hidden || document.webkitHidden || e.type == 'blur' ||
                  document.visibilityState != 'visible') {
                  this.stop();
                } else if (!this.crashed) {
                  this.tRex.reset();
                  this.play();
                }
              },
              /**
              * Play a sound.
              * @param {SoundBuffer} soundBuffer
              */
              playSound: function(soundBuffer) {
                if (soundBuffer) {
                  var sourceNode = this.audioContext.createBufferSource();
                  sourceNode.buffer = soundBuffer;
                  sourceNode.connect(this.audioContext.destination);
                  sourceNode.start(0);
                }
              },
              /**
              * Inverts the current page / canvas colors.
              * @param {boolean} Whether to reset colors.
              */
              invert: function(reset) {
                if (reset) {
                  document.body.classList.toggle(Runner.classes.INVERTED, false);
                  this.invertTimer = 0;
                  this.inverted = false;
                } else {
                  this.inverted = document.body.classList.toggle(Runner.classes.INVERTED,
                      this.invertTrigger);
                }
              }
            };
            
            
            /**
            * Updates the canvas size taking into
            * account the backing store pixel ratio and
            * the device pixel ratio.
            *
            * See article by Paul Lewis:
            * http://www.html5rocks.com/en/tutorials/canvas/hidpi/
            *
            * @param {HTMLCanvasElement} canvas
            * @param {number} opt_width
            * @param {number} opt_height
            * @return {boolean} Whether the canvas was scaled.
            */
            Runner.updateCanvasScaling = function(canvas, opt_width, opt_height) {
              var context = canvas.getContext('2d');
              // Query the various pixel ratios
              var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;
              var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;
              var ratio = devicePixelRatio / backingStoreRatio;
              // Upscale the canvas if the two ratios don't match
              if (devicePixelRatio !== backingStoreRatio) {
                var oldWidth = opt_width || canvas.width;
                var oldHeight = opt_height || canvas.height;
                canvas.width = oldWidth * ratio;
                canvas.height = oldHeight * ratio;
                canvas.style.width = oldWidth + 'px';
                canvas.style.height = oldHeight + 'px';
                // Scale the context to counter the fact that we've manually scaled
                // our canvas element.
                context.scale(ratio, ratio);
                return true;
              } else if (devicePixelRatio == 1) {
                // Reset the canvas width / height. Fixes scaling bug when the page is
                // zoomed and the devicePixelRatio changes accordingly.
                canvas.style.width = canvas.width + 'px';
                canvas.style.height = canvas.height + 'px';
              }
              return false;
            };
            /**
            * Get random number.
            * @param {number} min
            * @param {number} max
            * @param {number}
            */
            function getRandomNum(min, max) {
              return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            /**
            * Vibrate on mobile devices.
            * @param {number} duration Duration of the vibration in milliseconds.
            */
            function vibrate(duration) {
              if (IS_MOBILE && window.navigator.vibrate) {
                window.navigator.vibrate(duration);
              }
            }
            /**
            * Create canvas element.
            * @param {HTMLElement} container Element to append canvas to.
            * @param {number} width
            * @param {number} height
            * @param {string} opt_classname
            * @return {HTMLCanvasElement}
            */
            function createCanvas(container, width, height, opt_classname) {
              var canvas = document.createElement('canvas');
              canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +
                  opt_classname : Runner.classes.CANVAS;
              canvas.width = width;
              canvas.height = height;
              container.appendChild(canvas);
              return canvas;
            }
            /**
            * Decodes the base 64 audio to ArrayBuffer used by Web Audio.
            * @param {string} base64String
            */
            function decodeBase64ToArrayBuffer(base64String) {
              var len = (base64String.length / 4) * 3;
              var str = atob(base64String);
              var arrayBuffer = new ArrayBuffer(len);
              var bytes = new Uint8Array(arrayBuffer);
              for (var i = 0; i < len; i++) {
                bytes[i] = str.charCodeAt(i);
              }
              return bytes.buffer;
            }
            /**
            * Return the current timestamp.
            * @return {number}
            */
            function getTimeStamp() {
              return IS_IOS ? new Date().getTime() : performance.now();
            }
            //******************************************************************************
            /**
            * Game over panel.
            * @param {!HTMLCanvasElement} canvas
            * @param {Object} textImgPos
            * @param {Object} restartImgPos
            * @param {!Object} dimensions Canvas dimensions.
            * @constructor
            */
            function GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.canvasDimensions = dimensions;
              this.textImgPos = textImgPos;
              this.restartImgPos = restartImgPos;
              this.draw();
            };
            /**
            * Dimensions used in the panel.
            * @enum {number}
            */
            GameOverPanel.dimensions = {
              TEXT_X: 0,
              TEXT_Y: 13,
              TEXT_WIDTH: 191,
              TEXT_HEIGHT: 11,
              RESTART_WIDTH: 36,
              RESTART_HEIGHT: 32
            };
            GameOverPanel.prototype = {
              /**
              * Update the panel dimensions.
              * @param {number} width New canvas width.
              * @param {number} opt_height Optional new canvas height.
              */
              updateDimensions: function(width, opt_height) {
                this.canvasDimensions.WIDTH = width;
                if (opt_height) {
                  this.canvasDimensions.HEIGHT = opt_height;
                }
              },
              /**
              * Draw the panel.
              */
              draw: function() {
                var dimensions = GameOverPanel.dimensions;
                var centerX = this.canvasDimensions.WIDTH / 2;
                // Game over text.
                var textSourceX = dimensions.TEXT_X;
                var textSourceY = dimensions.TEXT_Y;
                var textSourceWidth = dimensions.TEXT_WIDTH;
                var textSourceHeight = dimensions.TEXT_HEIGHT;
                var textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));
                var textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);
                var textTargetWidth = dimensions.TEXT_WIDTH;
                var textTargetHeight = dimensions.TEXT_HEIGHT;
                var restartSourceWidth = dimensions.RESTART_WIDTH;
                var restartSourceHeight = dimensions.RESTART_HEIGHT;
                var restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);
                var restartTargetY = this.canvasDimensions.HEIGHT / 2;
                if (IS_HIDPI) {
                  textSourceY *= 2;
                  textSourceX *= 2;
                  textSourceWidth *= 2;
                  textSourceHeight *= 2;
                  restartSourceWidth *= 2;
                  restartSourceHeight *= 2;
                }
                textSourceX += this.textImgPos.x;
                textSourceY += this.textImgPos.y;
                // Game over text from sprite.
                this.canvasCtx.drawImage(Runner.imageSprite,
                    textSourceX, textSourceY, textSourceWidth, textSourceHeight,
                    textTargetX, textTargetY, textTargetWidth, textTargetHeight);
                // Restart button.
                this.canvasCtx.drawImage(Runner.imageSprite,
                    this.restartImgPos.x, this.restartImgPos.y,
                    restartSourceWidth, restartSourceHeight,
                    restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,
                    dimensions.RESTART_HEIGHT);
              }
            };
            //******************************************************************************
            /**
            * Check for a collision.
            * @param {!Obstacle} obstacle
            * @param {!Trex} tRex RunnerKRTV object.
            * @param {HTMLCanvasContext} opt_canvasCtx Optional canvas context for drawing
            *    collision boxes.
            * @return {Array<CollisionBox>}
            */
            function checkForCollision(obstacle, tRex, opt_canvasCtx) {
              var obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;
              // Adjustments are made to the bounding box as there is a 1 pixel white
              // border around the RunnerKRTV and obstacles.
              var tRexBox = new CollisionBox(
                  tRex.xPos + 1,
                  tRex.yPos + 1,
                  tRex.config.WIDTH - 2,
                  tRex.config.HEIGHT - 2);
              var obstacleBox = new CollisionBox(
                  obstacle.xPos + 1,
                  obstacle.yPos + 1,
                  obstacle.typeConfig.width * obstacle.size - 2,
                  obstacle.typeConfig.height - 2);
              // Debug outer box
              if (opt_canvasCtx) {
                drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);
              }
              // Simple outer bounds check.
              if (boxCompare(tRexBox, obstacleBox)) {
                var collisionBoxes = obstacle.collisionBoxes;
                var tRexCollisionBoxes = tRex.ducking ?
                    Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;
                // Detailed axis aligned box check.
                for (var t = 0; t < tRexCollisionBoxes.length; t++) {
                  for (var i = 0; i < collisionBoxes.length; i++) {
                    // Adjust the box to actual positions.
                    var adjTrexBox =
                        createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);
                    var adjObstacleBox =
                        createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);
                    var crashed = boxCompare(adjTrexBox, adjObstacleBox);
                    // Draw boxes for debug.
                    if (opt_canvasCtx) {
                      drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);
                    }
                    if (crashed) {
                      return [adjTrexBox, adjObstacleBox];
                    }
                  }
                }
              }
              return false;
            };
            /**
            * Adjust the collision box.
            * @param {!CollisionBox} box The original box.
            * @param {!CollisionBox} adjustment Adjustment box.
            * @return {CollisionBox} The adjusted collision box object.
            */
            function createAdjustedCollisionBox(box, adjustment) {
              return new CollisionBox(
                  box.x + adjustment.x,
                  box.y + adjustment.y,
                  box.width,
                  box.height);
            };
            /**
            * Draw the collision boxes for debug.
            */
            function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {
              canvasCtx.save();
              canvasCtx.strokeStyle = '#f00';
              canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);
              canvasCtx.strokeStyle = '#0f0';
              canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,
                  obstacleBox.width, obstacleBox.height);
              canvasCtx.restore();
            };
            /**
            * Compare two collision boxes for a collision.
            * @param {CollisionBox} tRexBox
            * @param {CollisionBox} obstacleBox
            * @return {boolean} Whether the boxes intersected.
            */
            function boxCompare(tRexBox, obstacleBox) {
              var crashed = false;
              var tRexBoxX = tRexBox.x;
              var tRexBoxY = tRexBox.y;
              var obstacleBoxX = obstacleBox.x;
              var obstacleBoxY = obstacleBox.y;
              // Axis-Aligned Bounding Box method.
              if (tRexBox.x < obstacleBoxX + obstacleBox.width &&
                  tRexBox.x + tRexBox.width > obstacleBoxX &&
                  tRexBox.y < obstacleBox.y + obstacleBox.height &&
                  tRexBox.height + tRexBox.y > obstacleBox.y) {
                crashed = true;
              }
              return crashed;
            };
            //******************************************************************************
            /**
            * Collision box object.
            * @param {number} x X position.
            * @param {number} y Y Position.
            * @param {number} w Width.
            * @param {number} h Height.
            */
            function CollisionBox(x, y, w, h) {
              this.x = x;
              this.y = y;
              this.width = w;
              this.height = h;
            };
            //******************************************************************************
            /**
            * Obstacle.
            * @param {HTMLCanvasCtx} canvasCtx
            * @param {Obstacle.type} type
            * @param {Object} spritePos Obstacle position in sprite.
            * @param {Object} dimensions
            * @param {number} gapCoefficient Mutipler in determining the gap.
            * @param {number} speed
            * @param {number} opt_xOffset
            */
            function Obstacle(canvasCtx, type, spriteImgPos, dimensions,
                gapCoefficient, speed, opt_xOffset) {
              this.canvasCtx = canvasCtx;
              this.spritePos = spriteImgPos;
              this.typeConfig = type;
              this.gapCoefficient = gapCoefficient;
              this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);
              this.dimensions = dimensions;
              this.remove = false;
              this.xPos = dimensions.WIDTH + (opt_xOffset || 0);
              this.yPos = 0;
              this.width = 0;
              this.collisionBoxes = [];
              this.gap = 0;
              this.speedOffset = 0;
              // For animated obstacles.
              this.currentFrame = 0;
              this.timer = 0;
              this.init(speed);
            };
            /**
            * Coefficient for calculating the maximum gap.
            * @const
            */
            Obstacle.MAX_GAP_COEFFICIENT = 1.5;
            /**
            * Maximum obstacle grouping count.
            * @const
            */
            Obstacle.MAX_OBSTACLE_LENGTH = 3,
            Obstacle.prototype = {
              /**
              * Initialise the DOM for the obstacle.
              * @param {number} speed
              */
              init: function(speed) {
                this.cloneCollisionBoxes();
                // Only allow sizing if we're at the right speed.
                if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {
                  this.size = 1;
                }
                this.width = this.typeConfig.width * this.size;
                // Check if obstacle can be positioned at various heights.
                if (Array.isArray(this.typeConfig.yPos))  {
                  var yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile :
                      this.typeConfig.yPos;
                  this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];
                } else {
                  this.yPos = this.typeConfig.yPos;
                }
                this.draw();
                // Make collision box adjustments,
                // Central box is adjusted to the size as one box.
                //      ____        ______        ________
                //    _|   |-|    _|     |-|    _|       |-|
                //   | |<->| |   | |<--->| |   | |<----->| |
                //   | | 1 | |   | |  2  | |   | |   3   | |
                //   |_|___|_|   |_|_____|_|   |_|_______|_|
                //
                if (this.size > 1) {
                  this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -
                      this.collisionBoxes[2].width;
                  this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
                }
                // For obstacles that go at a different speed from the horizon.
                if (this.typeConfig.speedOffset) {
                  this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :
                      -this.typeConfig.speedOffset;
                }
                this.gap = this.getGap(this.gapCoefficient, speed);
              },
              /**
              * Draw and crop based on size.
              */
              draw: function() {
                var sourceWidth = this.typeConfig.width;
                var sourceHeight = this.typeConfig.height;
                if (IS_HIDPI) {
                  sourceWidth = sourceWidth * 2;
                  sourceHeight = sourceHeight * 2;
                }
                // X position in sprite.
                var sourceX = (sourceWidth * this.size) * (0.5 * (this.size - 1)) +
                    this.spritePos.x;
                // Animation frames.
                if (this.currentFrame > 0) {
                  sourceX += sourceWidth * this.currentFrame;
                }
                this.canvasCtx.drawImage(Runner.imageSprite,
                  sourceX, this.spritePos.y,
                  sourceWidth * this.size, sourceHeight,
                  this.xPos, this.yPos,
                  this.typeConfig.width * this.size, this.typeConfig.height);
              },
              /**
              * Obstacle frame update.
              * @param {number} deltaTime
              * @param {number} speed
              */
              update: function(deltaTime, speed) {
                if (!this.remove) {
                  if (this.typeConfig.speedOffset) {
                    speed += this.speedOffset;
                  }
                  this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);
                  // Update frame
                  if (this.typeConfig.numFrames) {
                    this.timer += deltaTime;
                    if (this.timer >= this.typeConfig.frameRate) {
                      this.currentFrame =
                          this.currentFrame == this.typeConfig.numFrames - 1 ?
                          0 : this.currentFrame + 1;
                      this.timer = 0;
                    }
                  }
                  this.draw();
                  if (!this.isVisible()) {
                    this.remove = true;
                  }
                }
              },
              /**
              * Calculate a random gap size.
              * - Minimum gap gets wider as speed increses
              * @param {number} gapCoefficient
              * @param {number} speed
              * @return {number} The gap size.
              */
              getGap: function(gapCoefficient, speed) {
                var minGap = Math.round(this.width * speed +
                      this.typeConfig.minGap * gapCoefficient);
                var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);
                return getRandomNum(minGap, maxGap);
              },
              /**
              * Check if obstacle is visible.
              * @return {boolean} Whether the obstacle is in the game area.
              */
              isVisible: function() {
                return this.xPos + this.width > 0;
              },
              /**
              * Make a copy of the collision boxes, since these will change based on
              * obstacle type and size.
              */
              cloneCollisionBoxes: function() {
                var collisionBoxes = this.typeConfig.collisionBoxes;
                for (var i = collisionBoxes.length - 1; i >= 0; i--) {
                  this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x,
                      collisionBoxes[i].y, collisionBoxes[i].width,
                      collisionBoxes[i].height);
                }
              }
            };
            /**
            * Obstacle definitions.
            * minGap: minimum pixel space betweeen obstacles.
            * multipleSpeed: Speed at which multiples are allowed.
            * speedOffset: speed faster / slower than the horizon.
            * minSpeed: Minimum speed which the obstacle can make an appearance.
            */
            Obstacle.types = [
              {
                type: 'CACTUS_SMALL',
                width: 17,
                height: 35,
                yPos: 105,
                multipleSpeed: 4,
                minGap: 120,
                minSpeed: 0,
                collisionBoxes: [
                  new CollisionBox(0, 7, 5, 27),
                  new CollisionBox(4, 0, 6, 34),
                  new CollisionBox(10, 4, 7, 14)
                ]
              },
              {
                type: 'CACTUS_LARGE',
                width: 25,
                height: 50,
                yPos: 90,
                multipleSpeed: 7,
                minGap: 120,
                minSpeed: 0,
                collisionBoxes: [
                  new CollisionBox(0, 12, 7, 38),
                  new CollisionBox(8, 0, 7, 49),
                  new CollisionBox(13, 10, 10, 38)
                ]
              },
              {
                type: 'PTERODACTYL',
                width: 46,
                height: 40,
                yPos: [ 100, 75, 50 ], // Variable height.
                yPosMobile: [ 100, 50 ], // Variable height mobile.
                multipleSpeed: 999,
                minSpeed: 8.5,
                minGap: 150,
                collisionBoxes: [
                  new CollisionBox(15, 15, 16, 5),
                  new CollisionBox(18, 21, 24, 6),
                  new CollisionBox(2, 14, 4, 3),
                  new CollisionBox(6, 10, 4, 7),
                  new CollisionBox(10, 8, 6, 9)
                ],
                numFrames: 2,
                frameRate: 1000/6,
                speedOffset: .8
              }
            ];
            //******************************************************************************
            /**
            * RunnerKRTV game character.
            * @param {HTMLCanvas} canvas
            * @param {Object} spritePos Positioning within image sprite.
            * @constructor
            */
            function Trex(canvas, spritePos) {
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.spritePos = spritePos;
              this.xPos = 0;
              this.yPos = 0;
              // Position when on the ground.
              this.groundYPos = 0;
              this.currentFrame = 0;
              this.currentAnimFrames = [];
              this.blinkDelay = 0;
              this.blinkCount = 0;
              this.animStartTime = 0;
              this.timer = 0;
              this.msPerFrame = 1000 / FPS;
              this.config = Trex.config;
              // Current status.
              this.status = Trex.status.WAITING;
              this.jumping = false;
              this.ducking = false;
              this.jumpVelocity = 0;
              this.reachedMinHeight = false;
              this.speedDrop = false;
              this.jumpCount = 0;
              this.jumpspotX = 0;
              this.init();
            };
            /**
            * RunnerKRTV player config.
            * @enum {number}
            */
            Trex.config = {
              DROP_VELOCITY: -5,
              GRAVITY: 0.6,
              HEIGHT: 47,
              HEIGHT_DUCK: 25,
              INIITAL_JUMP_VELOCITY: -10,
              INTRO_DURATION: 1500,
              MAX_JUMP_HEIGHT: 30,
              MIN_JUMP_HEIGHT: 30,
              SPEED_DROP_COEFFICIENT: 3,
              SPRITE_WIDTH: 262,
              START_X_POS: 50,
              WIDTH: 44,
              WIDTH_DUCK: 59
            };
            /**
            * Used in collision detection.
            * @type {Array<CollisionBox>}
            */
            Trex.collisionBoxes = {
              DUCKING: [
                new CollisionBox(1, 18, 55, 25)
              ],
              RUNNING: [
                new CollisionBox(22, 0, 17, 16),
                new CollisionBox(1, 18, 30, 9),
                new CollisionBox(10, 35, 14, 8),
                new CollisionBox(1, 24, 29, 5),
                new CollisionBox(5, 30, 21, 4),
                new CollisionBox(9, 34, 15, 4)
              ]
            };
            /**
            * Animation states.
            * @enum {string}
            */
            Trex.status = {
              CRASHED: 'CRASHED',
              DUCKING: 'DUCKING',
              JUMPING: 'JUMPING',
              RUNNING: 'RUNNING',
              WAITING: 'WAITING'
            };
            /**
            * Blinking coefficient.
            * @const
            */
            Trex.BLINK_TIMING = 7000;
            /**
            * Animation config for different states.
            * @enum {Object}
            */
            Trex.animFrames = {
              WAITING: {
                frames: [44, 0],
                msPerFrame: 1000 / 3
              },
              RUNNING: {
                frames: [88, 132],
                msPerFrame: 1000 / 12
              },
              CRASHED: {
                frames: [220],
                msPerFrame: 1000 / 60
              },
              JUMPING: {
                frames: [0],
                msPerFrame: 1000 / 60
              },
              DUCKING: {
                frames: [262, 321],
                msPerFrame: 1000 / 8
              }
            };
            Trex.prototype = {
              /**
              * RunnerKRTV player initaliser.
              * Sets the RunnerKRTV to blink at random intervals.
              */
              init: function() {
                this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
                    Runner.config.BOTTOM_PAD;
                this.yPos = this.groundYPos;
                this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;
                this.draw(0, 0);
                this.update(0, Trex.status.WAITING);
              },
              /**
              * Setter for the jump velocity.
              * The approriate drop velocity is also set.
              */
              setJumpVelocity: function(setting) {
                this.config.INIITAL_JUMP_VELOCITY = -setting;
                this.config.DROP_VELOCITY = -setting / 2;
              },
              /**
              * Set the animation status.
              * @param {!number} deltaTime
              * @param {Trex.status} status Optional status to switch to.
              */
              update: function(deltaTime, opt_status) {
                this.timer += deltaTime;
                // Update the status.
                if (opt_status) {
                  this.status = opt_status;
                  this.currentFrame = 0;
                  this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;
                  this.currentAnimFrames = Trex.animFrames[opt_status].frames;
                  if (opt_status == Trex.status.WAITING) {
                    this.animStartTime = getTimeStamp();
                    this.setBlinkDelay();
                  }
                }
                // Game intro animation, RunnerKRTV moves in from the left.
                if (this.playingIntro && this.xPos < this.config.START_X_POS) {
                  this.xPos += Math.round((this.config.START_X_POS /
                      this.config.INTRO_DURATION) * deltaTime);
                }
                if (this.status == Trex.status.WAITING) {
                  this.blink(getTimeStamp());
                } else {
                  this.draw(this.currentAnimFrames[this.currentFrame], 0);
                }
                // Update the frame position.
                if (this.timer >= this.msPerFrame) {
                  this.currentFrame = this.currentFrame ==
                      this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;
                  this.timer = 0;
                }
                // Speed drop becomes duck if the down key is still being pressed.
                if (this.speedDrop && this.yPos == this.groundYPos) {
                  this.speedDrop = false;
                  this.setDuck(true);
                }
              },
              /**
              * Draw the RunnerKRTV to a particular position.
              * @param {number} x
              * @param {number} y
              */
              draw: function(x, y) {
                var sourceX = x;
                var sourceY = y;
                var sourceWidth = this.ducking && this.status != Trex.status.CRASHED ?
                    this.config.WIDTH_DUCK : this.config.WIDTH;
                var sourceHeight = this.config.HEIGHT;
                if (IS_HIDPI) {
                  sourceX *= 2;
                  sourceY *= 2;
                  sourceWidth *= 2;
                  sourceHeight *= 2;
                }
                // Adjustments for sprite sheet position.
                sourceX += this.spritePos.x;
                sourceY += this.spritePos.y;
                // Ducking.
                if (this.ducking && this.status != Trex.status.CRASHED) {
                  this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
                      sourceWidth, sourceHeight,
                      this.xPos, this.yPos,
                      this.config.WIDTH_DUCK, this.config.HEIGHT);
                } else {
                  // Crashed whilst ducking. Trex is standing up so needs adjustment.
                  if (this.ducking && this.status == Trex.status.CRASHED) {
                    this.xPos++;
                  }
                  // Standing / running
                  this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
                      sourceWidth, sourceHeight,
                      this.xPos, this.yPos,
                      this.config.WIDTH, this.config.HEIGHT);
                  
                }
              },
              /**
              * Sets a random time for the blink to happen.
              */
              setBlinkDelay: function() {
                this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);
              },
              /**
              * Make RunnerKRTV blink at random intervals.
              * @param {number} time Current time in milliseconds.
              */
              blink: function(time) {
                var deltaTime = time - this.animStartTime;
                
                if (deltaTime >= this.blinkDelay) {
                  this.draw(this.currentAnimFrames[this.currentFrame], 0);
                  if (this.currentFrame == 1) {
                    // Set new random delay to blink.
                    this.setBlinkDelay();
                    this.animStartTime = time;
                    this.blinkCount++;
                  }
                }
              },
              /**
              * Initialise a jump.
              * @param {number} speed
              */
              startJump: function(speed) {
                if (!this.jumping) {
                  this.update(0, Trex.status.JUMPING);
                  // Tweak the jump velocity based on the speed.
                  this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - (speed / 10);
                  this.jumping = true;
                  this.reachedMinHeight = false;
                  this.speedDrop = false;
                }
              },
              /**
              * Jump is complete, falling down.
              */
              endJump: function() {
                if (this.reachedMinHeight &&
                    this.jumpVelocity < this.config.DROP_VELOCITY) {
                  this.jumpVelocity = this.config.DROP_VELOCITY;
                }
              },
              /**
              * Update frame for a jump.
              * @param {number} deltaTime
              * @param {number} speed
              */
              updateJump: function(deltaTime, speed) {
                var msPerFrame = Trex.animFrames[this.status].msPerFrame;
                var framesElapsed = deltaTime / msPerFrame;
                // Speed drop makes Trex fall faster.
                if (this.speedDrop) {
                  this.yPos += Math.round(this.jumpVelocity *
                      this.config.SPEED_DROP_COEFFICIENT * framesElapsed);
                } else {
                  this.yPos += Math.round(this.jumpVelocity * framesElapsed);
                }
                this.jumpVelocity += this.config.GRAVITY * framesElapsed;
                // Minimum height has been reached.
                if (this.yPos < this.minJumpHeight || this.speedDrop) {
                  this.reachedMinHeight = true;
                }
                // Reached max height
                if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {
                  this.endJump();
                }
                // Back down at ground level. Jump completed.
                if (this.yPos > this.groundYPos) {
                  this.reset();
                  this.jumpCount++;
                }
                this.update(deltaTime);
              },
              /**
              * Set the speed drop. Immediately cancels the current jump.
              */
              setSpeedDrop: function() {
                this.speedDrop = true;
                this.jumpVelocity = 1;
              },
              /**
              * @param {boolean} isDucking.
              */
              setDuck: function(isDucking) {
                if (isDucking && this.status != Trex.status.DUCKING) {
                  this.update(0, Trex.status.DUCKING);
                  this.ducking = true;
                } else if (this.status == Trex.status.DUCKING) {
                  this.update(0, Trex.status.RUNNING);
                  this.ducking = false;
                }
              },
              /**
              * Reset the RunnerKRTV to running at start of game.
              */
              reset: function() {
                this.yPos = this.groundYPos;
                this.jumpVelocity = 0;
                this.jumping = false;
                this.ducking = false;
                this.update(0, Trex.status.RUNNING);
                this.midair = false;
                this.speedDrop = false;
                this.jumpCount = 0;
              }
            };
            //******************************************************************************
            /**
            * Handles displaying the distance meter.
            * @param {!HTMLCanvasElement} canvas
            * @param {Object} spritePos Image position in sprite.
            * @param {number} canvasWidth
            * @constructor
            */
            function DistanceMeter(canvas, spritePos, canvasWidth) {
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.image = Runner.imageSprite;
              this.spritePos = spritePos;
              this.x = 0;
              this.y = 5;
              this.currentDistance = 0;
              this.maxScore = 0;
              this.highScore = 0;
              this.container = null;
              this.digits = [];
              this.acheivement = false;
              this.defaultString = '';
              this.flashTimer = 0;
              this.flashIterations = 0;
              this.invertTrigger = false;
              this.config = DistanceMeter.config;
              this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;
              this.init(canvasWidth);
            };
            /**
            * @enum {number}
            */
            DistanceMeter.dimensions = {
              WIDTH: 10,
              HEIGHT: 13,
              DEST_WIDTH: 11
            };
            /**
            * Y positioning of the digits in the sprite sheet.
            * X position is always 0.
            * @type {Array<number>}
            */
            DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];
            /**
            * Distance meter config.
            * @enum {number}
            */
            DistanceMeter.config = {
              // Number of digits.
              MAX_DISTANCE_UNITS: 5,
              // Distance that causes achievement animation.
              ACHIEVEMENT_DISTANCE: 100,
              // Used for conversion from pixel distance to a scaled unit.
              COEFFICIENT: 0.025,
              // Flash duration in milliseconds.
              FLASH_DURATION: 1000 / 4,
              // Flash iterations for achievement animation.
              FLASH_ITERATIONS: 3
            };
            DistanceMeter.prototype = {
              /**
              * Initialise the distance meter to '00000'.
              * @param {number} width Canvas width in px.
              */
              init: function(width) {
                var maxDistanceStr = '';
                this.calcXPos(width);
                this.maxScore = this.maxScoreUnits;
                for (var i = 0; i < this.maxScoreUnits; i++) {
                  this.draw(i, 0);
                  this.defaultString += '0';
                  maxDistanceStr += '9';
                }
                this.maxScore = parseInt(maxDistanceStr);
              },
              /**
              * Calculate the xPos in the canvas.
              * @param {number} canvasWidth
              */
              calcXPos: function(canvasWidth) {
                this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *
                    (this.maxScoreUnits + 1));

              },
              /**
              * Draw a digit to canvas.
              * @param {number} digitPos Position of the digit.
              * @param {number} value Digit value 0-9.
              * @param {boolean} opt_highScore Whether drawing the high score.
              */
              draw: function(digitPos, value, opt_highScore) {
                var sourceWidth = DistanceMeter.dimensions.WIDTH;
                var sourceHeight = DistanceMeter.dimensions.HEIGHT;
                var sourceX = DistanceMeter.dimensions.WIDTH * value;
                var sourceY = 0;
                var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;
                var targetY = this.y;
                var targetWidth = DistanceMeter.dimensions.WIDTH;
                var targetHeight = DistanceMeter.dimensions.HEIGHT;
                // For high DPI we 2x source values.
                if (IS_HIDPI) {
                  sourceWidth *= 2;
                  sourceHeight *= 2;
                  sourceX *= 2;
                }
                sourceX += this.spritePos.x;
                sourceY += this.spritePos.y;
                this.canvasCtx.save();
                if (opt_highScore) {
                  // Left of the current score.
                  var highScoreX = this.x - (this.maxScoreUnits * 2) *
                      DistanceMeter.dimensions.WIDTH;
                  this.canvasCtx.translate(highScoreX, this.y);
                } else {
                  this.canvasCtx.translate(this.x, this.y);
                }

                this.canvasCtx.drawImage(this.image, sourceX, sourceY,
                    sourceWidth, sourceHeight,
                    targetX, targetY,
                    targetWidth, targetHeight
                  );
                this.canvasCtx.restore();
              },
              /**
              * Covert pixel distance to a 'real' distance.
              * @param {number} distance Pixel distance ran.
              * @return {number} The 'real' distance ran.
              */
              getActualDistance: function(distance) {
                return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;
              },
              /**
              * Update the distance meter.
              * @param {number} distance
              * @param {number} deltaTime
              * @return {boolean} Whether the acheivement sound fx should be played.
              */
              update: function(deltaTime, distance) {
                var paint = true;
                var playSound = false;
                if (!this.acheivement) {
                  distance = this.getActualDistance(distance);
                  // Score has gone beyond the initial digit count.
                  if (distance > this.maxScore && this.maxScoreUnits ==
                    this.config.MAX_DISTANCE_UNITS) {
                    this.maxScoreUnits++;
                    this.maxScore = parseInt(this.maxScore + '9');
                  } else {
                    this.distance = 0;
                  }
                  if (distance > 0) {
                    // Acheivement unlocked
                    if (distance % this.config.ACHIEVEMENT_DISTANCE == 0) {
                      // Flash score and play sound.
                      this.acheivement = true;
                      this.flashTimer = 0;
                      playSound = true;
                    }
                    // Create a string representation of the distance with leading 0.
                    var distanceStr = (this.defaultString +
                        distance).substr(-this.maxScoreUnits);
                    this.digits = distanceStr.split('');
                  } else {
                    this.digits = this.defaultString.split('');
                  }
                  //console.log(distance);/**/
                  getPriceSale(distance);
                } else {
                  // Control flashing of the score on reaching acheivement.
                  if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
                    this.flashTimer += deltaTime;
                    if (this.flashTimer < this.config.FLASH_DURATION) {
                      paint = false;
                    } else if (this.flashTimer >
                        this.config.FLASH_DURATION * 2) {
                      this.flashTimer = 0;
                      this.flashIterations++;
                    }
                  } else {
                    this.acheivement = false;
                    this.flashIterations = 0;
                    this.flashTimer = 0;
                  }
                }
                // Draw the digits if not flashing.
                if (paint) {
                  for (var i = this.digits.length - 1; i >= 0; i--) {
                    this.draw(i, parseInt(this.digits[i]));
                  }
                }
                this.drawHighScore();
                return playSound;
              },
              /**
              * Draw the high score.
              */
              drawHighScore: function() {
                this.canvasCtx.save();
                this.canvasCtx.globalAlpha = .8;
                for (var i = this.highScore.length - 1; i >= 0; i--) {
                  this.draw(i, parseInt(this.highScore[i], 10), true);
                }
                this.canvasCtx.restore();
              },
              /**
              * Set the highscore as a array string.
              * Position of char in the sprite: H - 10, I - 11.
              * @param {number} distance Distance ran in pixels.
              */
              setHighScore: function(distance) {
                distance = this.getActualDistance(distance);
                var highScoreStr = (this.defaultString +
                    distance).substr(-this.maxScoreUnits);
                this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));
              },
              /**
              * Reset the distance meter back to '00000'.
              */
              reset: function() {
                this.update(0);
                this.acheivement = false;
              }
            };
            //******************************************************************************
            /**
            * Cloud background item.
            * Similar to an obstacle object but without collision boxes.
            * @param {HTMLCanvasElement} canvas Canvas element.
            * @param {Object} spritePos Position of image in sprite.
            * @param {number} containerWidth
            */
            function Cloud(canvas, spritePos, containerWidth) {
              this.canvas = canvas;
              this.canvasCtx = this.canvas.getContext('2d');
              this.spritePos = spritePos;
              this.containerWidth = containerWidth;
              this.xPos = containerWidth;
              this.yPos = 0;
              this.remove = false;
              this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP,
                  Cloud.config.MAX_CLOUD_GAP);
              this.init();
            };
            /**
            * Cloud object config.
            * @enum {number}
            */
            Cloud.config = {
              HEIGHT: 14,
              MAX_CLOUD_GAP: 400,
              MAX_SKY_LEVEL: 30,
              MIN_CLOUD_GAP: 100,
              MIN_SKY_LEVEL: 71,
              WIDTH: 46
            };
            Cloud.prototype = {
              /**
              * Initialise the cloud. Sets the Cloud height.
              */
              init: function() {
                this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,
                    Cloud.config.MIN_SKY_LEVEL);
                this.draw();
              },
              /**
              * Draw the cloud.
              */
              draw: function() {
                this.canvasCtx.save();
                var sourceWidth = Cloud.config.WIDTH;
                var sourceHeight = Cloud.config.HEIGHT;
                if (IS_HIDPI) {
                  sourceWidth = sourceWidth * 2;
                  sourceHeight = sourceHeight * 2;
                }
                this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,
                    this.spritePos.y,
                    sourceWidth, sourceHeight,
                    this.xPos, this.yPos,
                    Cloud.config.WIDTH, Cloud.config.HEIGHT);
                this.canvasCtx.restore();
              },
              /**
              * Update the cloud position.
              * @param {number} speed
              */
              update: function(speed) {
                if (!this.remove) {
                  this.xPos -= Math.ceil(speed);
                  this.draw();
                  // Mark as removeable if no longer in the canvas.
                  if (!this.isVisible()) {
                    this.remove = true;
                  }
                }
              },
              /**
              * Check if the cloud is visible on the stage.
              * @return {boolean}
              */
              isVisible: function() {
                return this.xPos + Cloud.config.WIDTH > 0;
              }
            };
            
            
            
            //******************************************************************************
            /**
            * Nightmode shows a moon and stars on the horizon.
            */
            function NightMode(canvas, spritePos, containerWidth) {
              this.spritePos = spritePos;
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.xPos = containerWidth - 50;
              this.yPos = 30;
              this.currentPhase = 0;
              this.opacity = 0;
              this.containerWidth = containerWidth;
              this.stars = [];
              this.drawStars = false;
              this.placeStars();
            };
            /**
            * @enum {number}
            */
            NightMode.config = {
              FADE_SPEED: 0.035,
              HEIGHT: 40,
              MOON_SPEED: 0.25,
              NUM_STARS: 2,
              STAR_SIZE: 9,
              STAR_SPEED: 0.3,
              STAR_MAX_Y: 70,
              WIDTH: 20
            };
            NightMode.phases = [140, 120, 100, 60, 40, 20, 0];
            NightMode.prototype = {
              /**
              * Update moving moon, changing phases.
              * @param {boolean} activated Whether night mode is activated.
              * @param {number} delta
              */
              update: function(activated, delta) {
                // Moon phase.
                if (activated && this.opacity == 0) {
                  this.currentPhase++;
                  if (this.currentPhase >= NightMode.phases.length) {
                    this.currentPhase = 0;
                  }
                }
                // Fade in / out.
                if (activated && (this.opacity < 1 || this.opacity == 0)) {
                  this.opacity += NightMode.config.FADE_SPEED;
                } else if (this.opacity > 0) {
                  this.opacity -= NightMode.config.FADE_SPEED;
                }
                // Set moon positioning.
                if (this.opacity > 0) {
                  this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);
                  // Update stars.
                  if (this.drawStars) {
                    for (var i = 0; i < NightMode.config.NUM_STARS; i++) {
                        this.stars[i].x = this.updateXPos(this.stars[i].x,
                            NightMode.config.STAR_SPEED);
                    }
                  }
                  this.draw();
                } else {
                  this.opacity = 0;
                  this.placeStars();
                }
                this.drawStars = true;
              },
              updateXPos: function(currentPos, speed) {
                if (currentPos < -NightMode.config.WIDTH) {
                  currentPos = this.containerWidth;
                } else {
                  currentPos -= speed;
                }
                return currentPos;
              },
              draw: function() {
                var moonSourceWidth = this.currentPhase == 3 ? NightMode.config.WIDTH * 2 :
                    NightMode.config.WIDTH;
                var moonSourceHeight = NightMode.config.HEIGHT;
                var moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];
                var moonOutputWidth = moonSourceWidth;
                var starSize = NightMode.config.STAR_SIZE;
                var starSourceX = Runner.spriteDefinition.LDPI.STAR.x;
                if (IS_HIDPI) {
                  moonSourceWidth *= 2;
                  moonSourceHeight *= 2;
                  moonSourceX = this.spritePos.x +
                      (NightMode.phases[this.currentPhase] * 2);
                  starSize *= 2;
                  starSourceX = Runner.spriteDefinition.HDPI.STAR.x;
                }
                this.canvasCtx.save();
                this.canvasCtx.globalAlpha = this.opacity;
                // Stars.
                if (this.drawStars) {
                  for (var i = 0; i < NightMode.config.NUM_STARS; i++) {
                    this.canvasCtx.drawImage(Runner.imageSprite,
                        starSourceX, this.stars[i].sourceY, starSize, starSize,
                        Math.round(this.stars[i].x), this.stars[i].y,
                        NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);
                  }
                }
                // Moon.
                this.canvasCtx.drawImage(Runner.imageSprite, moonSourceX,
                    this.spritePos.y, moonSourceWidth, moonSourceHeight,
                    Math.round(this.xPos), this.yPos,
                    moonOutputWidth, NightMode.config.HEIGHT);
                this.canvasCtx.globalAlpha = 1;
                this.canvasCtx.restore();
              },
              // Do star placement.
              placeStars: function() {
                var segmentSize = Math.round(this.containerWidth /
                    NightMode.config.NUM_STARS);
                for (var i = 0; i < NightMode.config.NUM_STARS; i++) {
                  this.stars[i] = {};
                  this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));
                  this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);
                  if (IS_HIDPI) {
                    this.stars[i].sourceY = Runner.spriteDefinition.HDPI.STAR.y +
                        NightMode.config.STAR_SIZE * 2 * i;
                  } else {
                    this.stars[i].sourceY = Runner.spriteDefinition.LDPI.STAR.y +
                        NightMode.config.STAR_SIZE * i;
                  }
                }
              },
              reset: function() {
                this.currentPhase = 0;
                this.opacity = 0;
                this.update(false);
              }
            };
            //******************************************************************************
            /**
            * Horizon Line.
            * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.
            * @param {HTMLCanvasElement} canvas
            * @param {Object} spritePos Horizon position in sprite.
            * @constructor
            */
            function HorizonLine(canvas, spritePos) {
              this.spritePos = spritePos;
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.sourceDimensions = {};
              this.dimensions = HorizonLine.dimensions;
              this.sourceXPos = [this.spritePos.x, this.spritePos.x +
                  this.dimensions.WIDTH];
              this.xPos = [];
              this.yPos = 0;
              this.bumpThreshold = 0.5;
              this.setSourceDimensions();
              this.draw();
            };
            /**
            * Horizon line dimensions.
            * @enum {number}
            */
            HorizonLine.dimensions = {
              WIDTH: 600,
              HEIGHT: 12,
              YPOS: 133
            };
            HorizonLine.prototype = {
              /**
              * Set the source dimensions of the horizon line.
              */
              setSourceDimensions: function() {
                for (var dimension in HorizonLine.dimensions) {
                  if (IS_HIDPI) {
                    if (dimension != 'YPOS') {
                      this.sourceDimensions[dimension] =
                          HorizonLine.dimensions[dimension] * 2;
                    }
                  } else {
                    this.sourceDimensions[dimension] =
                        HorizonLine.dimensions[dimension];
                  }
                  this.dimensions[dimension] = HorizonLine.dimensions[dimension];
                }
                this.xPos = [0, HorizonLine.dimensions.WIDTH];
                this.yPos = HorizonLine.dimensions.YPOS;
              },
              /**
              * Return the crop x position of a type.
              */
              getRandomType: function() {
                return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;
              },
              /**
              * Draw the horizon line.
              */
              draw: function() {
                this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],
                    this.spritePos.y,
                    this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
                    this.xPos[0], this.yPos,
                    this.dimensions.WIDTH, this.dimensions.HEIGHT);
                this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],
                    this.spritePos.y,
                    this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
                    this.xPos[1], this.yPos,
                    this.dimensions.WIDTH, this.dimensions.HEIGHT);

              },
              /**
              * Update the x position of an indivdual piece of the line.
              * @param {number} pos Line position.
              * @param {number} increment
              */
              updateXPos: function(pos, increment) {
                var line1 = pos;
                var line2 = pos == 0 ? 1 : 0;
                this.xPos[line1] -= increment;
                this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;
                if (this.xPos[line1] <= -this.dimensions.WIDTH) {
                  this.xPos[line1] += this.dimensions.WIDTH * 2;
                  this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;
                  this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;
                }
              },
              /**
              * Update the horizon line.
              * @param {number} deltaTime
              * @param {number} speed
              */
              update: function(deltaTime, speed) {
                var increment = Math.floor(speed * (FPS / 1000) * deltaTime);
                if (this.xPos[0] <= 0) {
                  this.updateXPos(0, increment);
                } else {
                  this.updateXPos(1, increment);
                }
                this.draw();
              },
              /**
              * Reset horizon to the starting position.
              */
              reset: function() {
                this.xPos[0] = 0;
                this.xPos[1] = HorizonLine.dimensions.WIDTH;
              }
            };
            //******************************************************************************
            /**
            * Horizon background class.
            * @param {HTMLCanvasElement} canvas
            * @param {Object} spritePos Sprite positioning.
            * @param {Object} dimensions Canvas dimensions.
            * @param {number} gapCoefficient
            * @constructor
            */
            function Horizon(canvas, spritePos, dimensions, gapCoefficient) {
              this.canvas = canvas;
              this.canvasCtx = this.canvas.getContext('2d');
              this.config = Horizon.config;
              this.dimensions = dimensions;
              this.gapCoefficient = gapCoefficient;
              this.obstacles = [];
              this.obstacleHistory = [];
              this.horizonOffsets = [0, 0];
              this.cloudFrequency = this.config.CLOUD_FREQUENCY;
              this.spritePos = spritePos;
              this.nightMode = null;
              // Cloud
              this.clouds = [];
              this.cloudSpeed = this.config.BG_CLOUD_SPEED;
              // Horizon
              this.horizonLine = null;
              this.init();
            };
            /**
            * Horizon config.
            * @enum {number}
            */
            Horizon.config = {
              BG_CLOUD_SPEED: 0.2,
              BUMPY_THRESHOLD: .3,
              CLOUD_FREQUENCY: .5,
              HORIZON_HEIGHT: 16,
              MAX_CLOUDS: 6
            };
            Horizon.prototype = {
              /**
              * Initialise the horizon. Just add the line and a cloud. No obstacles.
              */
              init: function() {
                this.addCloud();
                this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);
                this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,
                    this.dimensions.WIDTH);
              },
              /**
              * @param {number} deltaTime
              * @param {number} currentSpeed
              * @param {boolean} updateObstacles Used as an override to prevent
              *     the obstacles from being updated / added. This happens in the
              *     ease in section.
              * @param {boolean} showNightMode Night mode activated.
              */
              update: function(deltaTime, currentSpeed, updateObstacles, showNightMode) {
                this.runningTime += deltaTime;
                this.horizonLine.update(deltaTime, currentSpeed);
                this.nightMode.update(showNightMode);
                this.updateClouds(deltaTime, currentSpeed);
                if (updateObstacles) {
                  this.updateObstacles(deltaTime, currentSpeed);
                }
              },
              /**
              * Update the cloud positions.
              * @param {number} deltaTime
              * @param {number} currentSpeed
              */
              updateClouds: function(deltaTime, speed) {
                var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;
                var numClouds = this.clouds.length;
                if (numClouds) {
                  for (var i = numClouds - 1; i >= 0; i--) {
                    this.clouds[i].update(cloudSpeed);
                  }
                  var lastCloud = this.clouds[numClouds - 1];
                  // Check for adding a new cloud.
                  if (numClouds < this.config.MAX_CLOUDS &&
                      (this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap &&
                      this.cloudFrequency > Math.random()) {
                    this.addCloud();
                  }
                  // Remove expired clouds.
                  this.clouds = this.clouds.filter(function(obj) {
                    return !obj.remove;
                  });
                } else {
                  this.addCloud();
                }
              },
              /**
              * Update the obstacle positions.
              * @param {number} deltaTime
              * @param {number} currentSpeed
              */
              updateObstacles: function(deltaTime, currentSpeed) {
                // Obstacles, move to Horizon layer.
                var updatedObstacles = this.obstacles.slice(0);
                for (var i = 0; i < this.obstacles.length; i++) {
                  var obstacle = this.obstacles[i];
                  obstacle.update(deltaTime, currentSpeed);
                  // Clean up existing obstacles.
                  if (obstacle.remove) {
                    updatedObstacles.shift();
                  }
                }
                this.obstacles = updatedObstacles;
                if (this.obstacles.length > 0) {
                  var lastObstacle = this.obstacles[this.obstacles.length - 1];
                  if (lastObstacle && !lastObstacle.followingObstacleCreated &&
                      lastObstacle.isVisible() &&
                      (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <
                      this.dimensions.WIDTH) {
                    this.addNewObstacle(currentSpeed);
                    lastObstacle.followingObstacleCreated = true;
                  }
                } else {
                  // Create new obstacles.
                  this.addNewObstacle(currentSpeed);
                }
              },
              removeFirstObstacle: function() {
                this.obstacles.shift();
              },
              /**
              * Add a new obstacle.
              * @param {number} currentSpeed
              */
              addNewObstacle: function(currentSpeed) {
                var obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);
                var obstacleType = Obstacle.types[obstacleTypeIndex];
                // Check for multiples of the same type of obstacle.
                // Also check obstacle is available at current speed.
                if (this.duplicateObstacleCheck(obstacleType.type) ||
                    currentSpeed < obstacleType.minSpeed) {
                  this.addNewObstacle(currentSpeed);
                } else {
                  var obstacleSpritePos = this.spritePos[obstacleType.type];
                  this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType,
                      obstacleSpritePos, this.dimensions,
                      this.gapCoefficient, currentSpeed, obstacleType.width));
                  this.obstacleHistory.unshift(obstacleType.type);
                  if (this.obstacleHistory.length > 1) {
                    this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);
                  }
                }
              },
              /**
              * Returns whether the previous two obstacles are the same as the next one.
              * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.
              * @return {boolean}
              */
              duplicateObstacleCheck: function(nextObstacleType) {
                var duplicateCount = 0;
                for (var i = 0; i < this.obstacleHistory.length; i++) {
                  duplicateCount = this.obstacleHistory[i] == nextObstacleType ?
                      duplicateCount + 1 : 0;
                }
                return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;
              },
              /**
              * Reset the horizon layer.
              * Remove existing obstacles and reposition the horizon line.
              */
              reset: function() {
                this.obstacles = [];
                this.horizonLine.reset();
                this.nightMode.reset();
              },
              /**
              * Update the canvas width and scaling.
              * @param {number} width Canvas width.
              * @param {number} height Canvas height.
              */
              resize: function(width, height) {
                this.canvas.width = width;
                this.canvas.height = height;
              },
              /**
              * Add a new cloud to the horizon.
              */
              addCloud: function() {
                this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,
                    this.dimensions.WIDTH));
              }
            };
          })();
            
            
          function onDocumentLoad() {
            new Runner('.interstitial-wrapper');
          }
          document.addEventListener('DOMContentLoaded', onDocumentLoad);

          function quadraticFunction(x) {
            var b = 0.0010;
            var maxAmplitude = 5; //   
            var y = maxAmplitude * Math.tanh(b * x);//  y   
            return y.toFixed(2);
          }

          console.log(" x=1500, y=" + quadraticFunction(1500));
          function getPriceSale(distance) {
            var element = document.getElementById('sale-title');
            var sale = calculateSale(distance);
            element.innerHTML = 'C   - ' + sale + ' %';
          }

          function calculateSale(distance) {
            let sale = quadraticFunction(distance);
            if(sale >= 5) {
              sale = 5;
            }
            return sale;
          }
          
          function arrayToNumber(arr) {
            return parseInt(arr.join(''), 10);
          }
        </script>
  </body>
</html>